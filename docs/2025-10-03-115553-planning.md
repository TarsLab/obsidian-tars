# MCP Integration Implementation Plan

**Created**: 2025-10-03
**Based on**: [2025-10-03-mcp-integration-review.md](2025-10-03-mcp-integration-review.md)
**Status**: In Progress
**Total Story Points**: Î£(16+28+26+23+23+13+18+31)=178
**Completed**: 30 SP (Epic-100: 18 SP, Epic-200: 12 SP)

---

## Planning Principles & Instructions for LLMs

### Purpose
This document provides a structured breakdown of the MCP integration work identified in the review. It is designed to be consumed by LLMs (including future sessions) to understand the work scope, priorities, and implementation approach.

### Numbering System
- **Epic**: `Epic-{N00}` (e.g., Epic-100, Epic-200) - increments of 100
- **Feature**: `Feature-{Epic}-{N0}` (e.g., Feature-100-10, Feature-100-20) - increments of 10
- **UserStory**: `UserStory-{Feature}-{N}` (e.g., UserStory-100-10-5) - increments of 5
- **Task**: `Task-{UserStory}-{N}` (e.g., Task-100-10-5-1) - increments of 1

**Rationale**: Gaps between numbers allow inserting newly-discovered work items during implementation without renumbering. For example, if during Task-100-10-5-1 we discover a missing prerequisite, we can insert Task-100-10-5-0 without disrupting the sequence.

### Story Points Scale (AI + Human Review)
- **1 (AI <=1h / Review <=2h)**: Simple 1-file change (<10 lines), no new dependencies
- **2 (AI <=4h / Review <=1d)**: Simple logic change, 1-2 files (<50 lines), relies on existing patterns
- **3 (AI <=8h / Review <=2d)**: Moderate complexity, 2-3 files, introduces or updates tests
- **5 (AI <=1d / Review <=3d)**: Complex logic across multiple files, new component/class, coordinated testing
- **8 (AI <=2d / Review <=1w)**: Very complex, architectural or cross-cutting changes, requires staged delivery
- **13+**: MUST break down furtherâ€”scope would exceed the AI sprint window or >1w human review queue

**Note**: Estimates include time for AI implementation + human review/approval cycle. Human review is typically 2-3x longer than AI implementation.

### Priority Levels
- **P0**: Production blocker - prevents deployment, breaks core functionality
- **P1**: Critical for release - core features, major bugs
- **P2**: Important for user experience - UX improvements, performance
- **P3**: Nice to have - advanced features, optimizations
- **P4**: Future consideration - deferred for later releases

### Acceptance Criteria Format
Each item should have clear, testable acceptance criteria using Given-When-Then format:

```
**Acceptance Criteria**:
- Given: [Initial state/context]
- When: [Action taken]
- Then: [Expected outcome/behavior]
```

### Implementation Instructions for LLMs

When implementing tasks from this plan:

1. **Start with Epic-100** (Production Blockers) - these unblock deployment
2. **Follow task order within each Epic** - dependencies are implicit in ordering
3. **Complete all tasks in a UserStory** before moving to next story
4. **Update this document** if you discover new tasks/stories during implementation
5. **Mark completed items** by changing status or adding completion notes
6. **Create tests** for all code changes (acceptance criteria define test cases)
7. **Document deviations** if implementation differs from plan

### Definition of Done (TDD Approach)

For every task and user story to be considered complete:

**Development Phase (AI Implementation):**
- âœ… Failing test(s) written first to capture the defect or requirement (red test)
- âœ… Code changes make those tests pass (green test)
- âœ… No regressions introduced (all existing suites stay green)
- âœ… Test coverage for new/modified modules >=85%
- âœ… Observable behavior documented in settings/help copy if needed

**Review Phase (Human Verification):**
- âœ… Manual verification completed using provided test scenarios
- âœ… Screenshots/logs captured for UI/behavior changes
- âœ… Edge cases and error conditions manually tested
- âœ… Performance impact assessed (if applicable)
- âœ… Reviewer sign-off with initials and date

**Quality Gates:**
- âœ… Linting passes (ESLint/Biome)
- âœ… Type checking passes (TypeScript)
- âœ… Build completes successfully
- âœ… Security scan passes (if external dependencies added)

### Cross-References
- Original review: [2025-10-03-mcp-integration-review.md](2025-10-03-mcp-integration-review.md)
- Codebase root: `src/`
- Test root: `tests/`

---

## Epic-100: Critical Bug Fixes (Production Blockers)

**Priority**: P0
**Story Points**: Î£(3+3+3+3+2+2)=16
**Status**: Not Started
**Description**: Fix critical bugs that prevent MCP integration from functioning in production. These issues break core functionality and must be addressed before any new development.

**Dependencies**: None (highest priority)
**Risk**: High - without these fixes, MCP integration is non-functional

### Feature-100-10: Fix Server Initialization

**Priority**: P0
**Story Points**: 3
**Description**: Resolve ID/name mismatch between configuration adapter and session manager that prevents servers from starting.

**Files Affected**:
- `src/mcp/mcpUseAdapter.ts`
- `src/mcp/managerMCPUse.ts`
- `tests/mcp/mcpUseAdapter.test.ts`

#### UserStory-100-10-5: ID/Name Mismatch Resolution

**Priority**: P0
**Story Points**: 3
**Description**: As a developer, I need server IDs to be used consistently across the MCP client and session manager so that new servers can be successfully initialized and connected.

**Background**: Currently `toMCPUseConfig` registers servers under `config.name`, but `createSession` is called with `config.id`. This mismatch causes "Server not found in config" errors.

**Solution Approach**: Align on using `config.id` as the primary identifier throughout the lifecycle.

##### Task-100-10-5-1: Update mcpUseAdapter to use config.id

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/mcpUseAdapter.test.ts` (test first), `src/mcp/mcpUseAdapter.ts`
**Line**: ~41

**TDD Approach**:
1. Write failing test for ID/name mismatch scenario
2. Update adapter to use `config.id || config.name`
3. Verify test passes

**Changes Required**:
```typescript
// Before:
const serverKey = config.name

// After:
const serverKey = config.id || config.name
```

**Acceptance Criteria**:
- Given: A server configuration with both `id` and `name` fields
- When: Converting to MCP-use format via `toMCPUseServerConfig`
- Then: The map key uses `config.id` consistently
- And: Server sessions can be created successfully with ID

##### Task-100-10-5-2: Update managerMCPUse session creation

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/managerMCPUse.ts`
**Line**: ~68

**Changes Required**:
```typescript
// Ensure createSession and sessions.set use the same identifier
const session = await this.mcpClient.createSession(config.id, true)
this.sessions.set(config.id, session)
```

**Acceptance Criteria**:
- Given: A server ID passed to `createSession`
- When: Creating a new MCP session
- Then: The `sessions` map stores the session under the same `config.id` key

##### Task-100-10-5-3: Add unit tests for ID/name alignment

**Story Points**: 1
**Priority**: P0
**File**: `tests/mcp/mcpUseAdapter.test.ts` (create if needed)

**Test Cases**:
1. Server with matching ID and name
2. Server with different ID and name
3. Server with only name (no ID)

**Acceptance Criteria**:
- Given: A test server config with ID="mcp-server-123" and name="filesystem"
- When: Creating a session via the manager
- Then: Session is successfully created and retrievable by ID

### Feature-100-20: Enable Configuration Settings

**Priority**: P0
**Story Points**: 3
**Description**: Wire user-configured timeout and execution limits from settings UI to the executor, replacing hardcoded values.

**Files Affected**:
- `src/mcp/index.ts`
- `src/main.ts`
- `src/mcp/executor.ts`

#### UserStory-100-20-5: Wire Timeout Settings

**Priority**: P0
**Story Points**: 3
**Description**: As a user, I need my configured timeout settings to be respected so that I can control how long tools are allowed to execute.

**Background**: The executor hardcodes a 30-second timeout. Settings UI captures `mcpGlobalTimeout` but it's never used.

##### Task-100-20-5-0: Add regression test for executor options

**Story Points**: 1
**Priority**: P0
**File**: `tests/mcp/executor.test.ts`

**Test Cases**:
1. Executor created without options retains defaults
2. Executor created with custom timeout/limits respects settings

**Acceptance Criteria**:
- Given: The current executor factory with hardcoded defaults
- When: Running the new regression test before refactor
- Then: The test fails because settings-driven values are ignored

##### Task-100-20-5-1: Update createToolExecutor signature

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/index.ts`
**Line**: ~56-75

**Changes Required**:
```typescript
export function createToolExecutor(
  manager: MCPServerManager,
  options?: {
    timeout?: number
    concurrentLimit?: number
    sessionLimit?: number
  }
): ToolExecutor {
  const tracker = {
    concurrentLimit: options?.concurrentLimit ?? 3,
    sessionLimit: options?.sessionLimit ?? 25,
    timeout: options?.timeout ?? 30000,
    // ... other properties
  }
  return new ToolExecutor(manager, tracker)
}
```

**Acceptance Criteria**:
- Given: The `createToolExecutor` function signature
- When: Adding an optional `options` parameter
- Then: Accepts `timeout`, `concurrentLimit`, and `sessionLimit` fields

##### Task-100-20-5-2: Thread settings from main.ts

**Story Points**: 1
**Priority**: P0
**File**: `src/main.ts`
**Line**: ~47

**Changes Required**:
```typescript
this.mcpExecutor = createToolExecutor(this.mcpManager, {
  timeout: this.settings.mcpGlobalTimeout,
  concurrentLimit: this.settings.mcpConcurrentLimit,
  sessionLimit: this.settings.mcpSessionLimit
})
```

**Acceptance Criteria**:
- Given: Plugin settings loaded with user-configured timeout/limits
- When: Creating the tool executor in `main.ts`
- Then: Settings values are passed to the executor factory function

#### UserStory-100-20-10: Apply Execution Limits

**Priority**: P0
**Story Points**: 1
**Description**: As a user, I need my configured concurrent and session limits to be enforced so that resource usage is controlled.

##### Task-100-20-10-1: Update executor tracker initialization

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/executor.ts`
**Line**: ~79-96 (canExecute method)

**Changes Required**:
- Ensure `tracker.concurrentLimit` and `tracker.sessionLimit` are set from passed options
- Remove any hardcoded defaults in executor constructor

**Acceptance Criteria**:
- Given: User-configured limits passed to executor
- When: `canExecute()` checks execution limits
- Then: Uses configured values instead of hardcoded 3 and 25

### Feature-100-40: Fix Inefficient Tool Discovery

**Priority**: P0
**Story Points**: 3
**Description**: Cache tool server mappings to eliminate redundant async calls on every request.

**Files Affected**:
- `src/mcp/providerAdapters.ts`
- `tests/mcp/providerAdapters.test.ts`

#### UserStory-100-40-5: Implement Tool Mapping Cache

**Priority**: P0
**Story Points**: 3
**Description**: As a system, I need to cache `buildToolServerMapping` results so that I don't make redundant tool listing calls on every request.

##### Task-100-40-5-1: Add cache storage to provider adapters

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
export class OpenAIProviderAdapter implements ProviderAdapter<OpenAI.ChatCompletionChunk> {
  private toolMappingCache: Map<string, string> | null = null
  private cacheTimestamp: number = 0

  async initialize(): Promise<void> {
    this.toolMappingCache = await buildToolServerMapping(this.mcpManager)
    this.cacheTimestamp = Date.now()
  }
}
```

**Acceptance Criteria**:
- Given: A provider adapter instance
- When: `initialize()` is called
- Then: Tool mapping is cached and timestamp recorded

##### Task-100-40-5-2: Use cached mapping in buildTools

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
async buildTools() {
  if (!this.toolMappingCache) {
    await this.initialize()
  }
  // Use this.toolMappingCache instead of calling buildToolServerMapping
}
```

**Acceptance Criteria**:
- Given: Cached tool mapping exists
- When: `buildTools()` is called
- Then: Uses cached mapping instead of making async call

##### Task-100-40-5-3: Invalidate cache on server changes

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
private invalidateCache(): void {
  this.toolMappingCache = null
  this.cacheTimestamp = 0
}

// Listen to manager events
this.mcpManager.on('server-started', () => this.invalidateCache())
this.mcpManager.on('server-stopped', () => this.invalidateCache())
```

**Acceptance Criteria**:
- Given: Server configuration changes
- When: Server starts or stops
- Then: Tool mapping cache is invalidated

### Feature-100-50: Fix Memory Leaks

**Priority**: P0
**Story Points**: 2
**Description**: Ensure proper cleanup of active executions on all error paths to prevent memory leaks.

**Files Affected**:
- `src/mcp/executor.ts`
- `tests/mcp/executor.test.ts`

#### UserStory-100-50-5: Fix Execution Cleanup

**Priority**: P0
**Story Points**: 2
**Description**: As a system, I need to ensure `activeExecutions` is cleaned up on ALL error paths so that memory doesn't leak during errors.

##### Task-100-50-5-1: Audit error paths in executor

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/executor.ts`

**Action Items**:
- Review all methods in `ToolExecutor`
- Identify all error paths that might skip cleanup
- Document paths that need fixing

**Acceptance Criteria**:
- Given: All executor methods
- When: Reviewing error handling
- Then: Documented all paths that might skip `activeExecutions.delete()`

##### Task-100-50-5-2: Add cleanup to error handlers

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Ensure `finally` blocks handle cleanup
- Add try-catch around cleanup code itself
- Use `executionRecord.requestId` for guaranteed cleanup

**Acceptance Criteria**:
- Given: Error occurring in `executeTool`
- When: Exception is thrown
- Then: `activeExecutions.delete()` is still called in finally block

### Feature-100-30: Activate Health Monitoring

**Priority**: P0
**Story Points**: 3
**Description**: Start the periodic health check timer that monitors MCP server status.

**Files Affected**:
- `src/main.ts`
- `src/mcp/index.ts` (for HEALTH_CHECK_INTERVAL constant)

#### UserStory-100-30-5: Start Health Check Timer

**Priority**: P0
**Story Points**: 3
**Description**: As a plugin user, I need automatic health monitoring of MCP servers so that I know when servers fail or disconnect.

**Background**: `HEALTH_CHECK_INTERVAL` constant exists but `performHealthCheck()` is never called automatically.

##### Task-100-30-5-0: Write timer orchestration test

**Story Points**: 1
**Priority**: P0
**File**: `tests/mcp/managerMCPUse.test.ts`

**Test Cases**:
1. Plugin load schedules health check interval when MCP manager exists
2. Plugin unload clears interval and leaves no dangling timers

**Acceptance Criteria**:
- Given: A mocked timer environment
- When: Running the new orchestration test before implementing the timer
- Then: The test fails because the interval is not yet scheduled or cleared

##### Task-100-30-5-1: Add setInterval in main.ts onload

**Story Points**: 1
**Priority**: P0
**File**: `src/main.ts`
**Line**: After line 47 (after creating mcpExecutor)

**Changes Required**:
```typescript
if (this.mcpManager) {
  this.healthCheckInterval = setInterval(async () => {
    await this.mcpManager.performHealthCheck()
    this.updateMCPStatus()
  }, HEALTH_CHECK_INTERVAL)
}
```

**Acceptance Criteria**:
- Given: MCP manager initialized successfully
- When: Plugin loads
- Then: Health check runs automatically every 30 seconds (HEALTH_CHECK_INTERVAL)

##### Task-100-30-5-2: Clear timer in onunload

**Story Points**: 1
**Priority**: P0
**File**: `src/main.ts`
**Line**: Before line 169 (in onunload method)

**Changes Required**:
```typescript
if (this.healthCheckInterval) {
  clearInterval(this.healthCheckInterval)
}
```

**Acceptance Criteria**:
- Given: Plugin unloading
- When: `onunload()` is called
- Then: Health check timer is properly cleared to prevent memory leaks

### Feature-100-90: Release Validation & Sign-Off

**Priority**: P0
**Story Points**: 2
**Description**: Capture manual verification and approval activities required before promoting fixes to production.

#### UserStory-100-90-5: Human Review & Release Approval

**Priority**: P0
**Story Points**: 2
**Description**: As a release manager, I need documented manual validation so that production fixes are signed off confidently.

##### Task-100-90-5-1: Conduct manual verification and document sign-off

**Story Points**: 2
**Priority**: P0
**Files**: `docs/release-notes.md`, `tests/manual/mcp-health-check.md` (new)

**Actions Required**:
- Execute smoke tests covering server start, timeout configuration, and health timers in a staging vault
- Capture observed results, screenshots/logs, and reviewer initials in release notes

**Acceptance Criteria**:
- Given: P0 fixes merged to main
- When: Manual verification is completed
- Then: Release notes include evidence and reviewer approval prior to deployment

---

## Epic-200: Core Missing Features

**Priority**: P1
**Story Points**: Î£(10+8+8+2)=28
**Status**: Not Started
**Description**: Implement core features that are expected for a complete MCP integration but are currently missing.

**Dependencies**: Epic-100 (blockers must be fixed first)
**Risk**: Medium - affects user experience and feature completeness

### Feature-200-10: Auto-Disable Failed Servers

**Priority**: P1
**Story Points**: Î£(5+5)=10
**Description**: Automatically disable servers that fail repeatedly to prevent resource waste and improve UX.

**Files Affected**:
- `src/mcp/managerMCPUse.ts`
- `src/settingTab.ts` (for UI updates)

#### UserStory-200-10-5: Implement Failure Tracking

**Priority**: P1
**Story Points**: 5
**Description**: As a system, I need to track consecutive failures per server so that I can auto-disable chronically failing servers.

##### Task-200-10-5-0: Add failure counter regression test

**Story Points**: 1
**Priority**: P1
**File**: `tests/mcp/managerMCPUse.test.ts`

**Test Cases**:
1. `startServer` failure increments `failureCount`
2. Successful start resets `failureCount`

**Acceptance Criteria**:
- Given: The current implementation without failure tracking
- When: Running the regression test before implementing fixes
- Then: The test fails because the counter is missing or not reset

##### Task-200-10-5-1: Add failureCount to server config

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
- Add `failureCount?: number` to `MCPServerConfig` interface
- Initialize to 0 when server is created

**Acceptance Criteria**:
- Given: MCPServerConfig interface definition
- When: A server config is created
- Then: `failureCount` field is available and defaults to 0

##### Task-200-10-5-2: Increment on startServer failure

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`
**Line**: ~88-113 (startServer method)

**Changes Required**:
```typescript
async startServer(serverId: string): Promise<void> {
  const config = this.servers.get(serverId)
  try {
    const session = await this.mcpClient.createSession(serverId, true)
    this.sessions.set(serverId, session)
    config.failureCount = 0  // Reset on success
    this.emit('server-started', serverId)
  } catch (error) {
    config.failureCount = (config.failureCount || 0) + 1
    // ... existing error handling
  }
}
```

**Acceptance Criteria**:
- Given: A server start attempt that fails
- When: Error is caught in the catch block
- Then: `failureCount` is incremented by 1

##### Task-200-10-5-3: Reset on successful start

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`

**Acceptance Criteria**:
- Given: A server with `failureCount > 0`
- When: Server successfully starts
- Then: `failureCount` is reset to 0

#### UserStory-200-10-10: Auto-Disable Logic

**Priority**: P1
**Story Points**: 5
**Description**: As a user, I need servers that fail 3+ times consecutively to be auto-disabled so that they don't continue consuming resources.

##### Task-200-10-10-1: Check threshold and disable

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`
**Line**: ~88-113 (startServer catch block)

**Changes Required**:
```typescript
catch (error) {
  config.failureCount = (config.failureCount || 0) + 1
  if (config.failureCount >= 3) {
    config.enabled = false
    config.autoDisabled = true
    this.emit('server-auto-disabled', serverId)
  }
  throw error
}
```

**Acceptance Criteria**:
- Given: A server with 3 or more consecutive failures
- When: Another failure occurs
- Then: Server is marked as `enabled=false` and `autoDisabled=true`

##### Task-200-10-10-2: Emit server-auto-disabled event

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
- Emit event when auto-disable threshold is reached
- Update UI to show "Auto-disabled" status
- Add "Re-enable" button in settings

**Acceptance Criteria**:
- Given: A server that gets auto-disabled
- When: The `server-auto-disabled` event is emitted
- Then: UI is notified and updates the server status display

##### Task-200-10-10-3: Validate auto-disable flow via Playwright

**Story Points**: 2
**Priority**: P1
**File**: `tests/e2e-ui/mcp-auto-disable.spec.ts` (new)

**Scenario Steps**:
1. Seed a mock server that fails three consecutive starts
2. Observe settings UI transition to "Auto-disabled" with re-enable control
3. Verify re-enable button clears the auto-disabled flag after manual confirmation

**Acceptance Criteria**:
- Given: The Playwright suite runs against a test vault
- When: The auto-disable scenario executes
- Then: The UI reflects "Auto-disabled" state and the test asserts the presence of the re-enable action

### Feature-200-20: Claude Provider Integration

**Priority**: P1
**Story Points**: 8
**Description**: Enable MCP tool calling for Claude/Anthropic provider, currently missing despite being advertised as supported.

**Files Affected**:
- `src/mcp/providerAdapters.ts` (new ClaudeProviderAdapter)
- `src/providers/claude.ts`
- `src/mcp/toolResponseParser.ts` (new ClaudeToolResponseParser)
- `tests/mcp/claudeProviderAdapter.test.ts` (new)

#### UserStory-200-20-5: Create Claude Provider Adapter

**Priority**: P1
**Story Points**: 5
**Description**: As a Claude user, I need an adapter that translates MCP tools into Claude's tool format so that I can use MCP tools with Claude models.

##### Task-200-20-5-1: Create ClaudeProviderAdapter class

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
export class ClaudeProviderAdapter implements ProviderAdapter<Anthropic.MessageStreamEvent> {
  async initialize(): Promise<void> { ... }
  async *sendRequest(messages: Message[]): AsyncGenerator<Anthropic.MessageStreamEvent> { ... }
  getParser(): ClaudeToolResponseParser { ... }
  findServerId(toolName: string): string | null { ... }
  formatToolResult(toolCallId: string, result: ToolExecutionResult): Message { ... }
}
```

**Acceptance Criteria**:
- Given: The `ProviderAdapter` interface
- When: Implementing `ClaudeProviderAdapter`
- Then: All interface methods are implemented and match Claude's API structure

##### Task-200-20-5-2: Implement buildTools for Claude format

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
- Use `buildClaudeTools` from `providerToolIntegration.ts`
- Claude format uses `input_schema` not `parameters`

**Acceptance Criteria**:
- Given: MCP tools with parameter schemas
- When: Converting for Claude
- Then: Tools use `input_schema` field (Claude-specific format)

##### Task-200-20-5-3: Implement formatToolResult for Claude

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
formatToolResult(toolCallId: string, result: ToolExecutionResult): Message {
  return {
    role: 'user',
    content: [{
      type: 'tool_result',
      tool_use_id: toolCallId,
      content: JSON.stringify(result.content)
    }]
  }
}
```

**Acceptance Criteria**:
- Given: A tool execution result
- When: Formatting for Claude
- Then: Returns proper `tool_result` message in Claude's format

##### Task-200-20-5-4: Add ClaudeToolResponseParser

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolResponseParser.ts`

**Changes Required**:
- Parse `Anthropic.MessageStreamEvent` for `tool_use` content blocks
- Accumulate streaming tool use blocks
- Extract tool ID, name, and input

**Acceptance Criteria**:
- Given: Anthropic streaming events with tool use
- When: Parsing chunks
- Then: Correctly extracts `tool_use` blocks with ID, name, and input

#### UserStory-200-20-10: Integrate into Claude Provider

**Priority**: P1
**Story Points**: 3
**Description**: As a developer, I need the Claude provider to use the new adapter so that tool calling is available in Claude conversations.

##### Task-200-20-10-1: Update sendRequestFunc signature

**Story Points**: 1
**Priority**: P1
**File**: `src/providers/claude.ts`

**Changes Required**:
- Add optional `mcpManager` and `mcpExecutor` parameters to `sendRequestFunc`
- Follow the pattern used in `src/providers/ollama.ts:11-52`

**Acceptance Criteria**:
- Given: The `sendRequestFunc` function in claude.ts
- When: Adding MCP dependencies
- Then: Accepts optional `mcpManager` and `mcpExecutor` parameters

##### Task-200-20-10-2: Route through ToolCallingCoordinator

**Story Points**: 1
**Priority**: P1
**File**: `src/providers/claude.ts`

**Changes Required**:
```typescript
if (mcpManager && mcpExecutor) {
  const { ToolCallingCoordinator, ClaudeProviderAdapter } = await import('../mcp/index.js')

  const adapter = new ClaudeProviderAdapter({
    mcpManager, mcpExecutor, anthropicClient, controller, model
  })

  await adapter.initialize()
  const coordinator = new ToolCallingCoordinator()

  yield* coordinator.generateWithTools(
    formattedMessages, adapter, mcpExecutor, { documentPath }
  )
}
```

**Acceptance Criteria**:
- Given: MCP manager and executor available
- When: Streaming Claude response
- Then: Uses `ToolCallingCoordinator` for autonomous tool execution

##### Task-200-20-10-3: Add unit tests for Claude adapter

**Story Points**: 1
**Priority**: P1
**File**: `tests/mcp/claudeProviderAdapter.test.ts` (new)

**Test Cases**:
1. Initialize adapter and build tools
2. Parse tool_use from streaming events
3. Format tool results correctly
4. Handle multi-turn conversation with tools

**Acceptance Criteria**:
- Given: Mock Anthropic streaming events
- When: Running adapter tests
- Then: All tool calling scenarios pass (init, parse, format, multi-turn)

### Feature-200-30: Tool Result Persistence

**Priority**: P0
**Story Points**: 8
**Description**: Write tool calls and results to markdown documents so users can see what tools were executed and audit LLM behavior.

**Files Affected**:
- `src/mcp/toolCallingCoordinator.ts`
- `src/editor.ts`

#### UserStory-200-30-5: Persist Tool Calls in Documents

**Priority**: P1
**Story Points**: 8
**Description**: As a user, I need tool invocations written to my markdown document so that I have a record of what tools were called during AI generation.

##### Task-200-30-5-0: Add integration test for markdown persistence

**Story Points**: 1
**Priority**: P1
**File**: `tests/mcp/toolCallingCoordinator.integration.test.ts` (new)

**Test Cases**:
1. Coordinator logs tool call metadata into a mocked editor buffer
2. Tool result markdown is appended with duration and content

**Acceptance Criteria**:
- Given: The current coordinator implementation without persistence
- When: Running the integration test before code changes
- Then: The test fails because markdown is not written to the buffer

##### Task-200-30-5-1: Modify ToolCallingCoordinator to accept editor

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
```typescript
async *generateWithTools(
  messages: Message[],
  adapter: ProviderAdapter,
  executor: ToolExecutor,
  options: GenerateOptions & { editor?: Editor }
): AsyncGenerator<string>
```

**Acceptance Criteria**:
- Given: The `generateWithTools` method signature
- When: Adding optional `editor` to options
- Then: Editor is available for inserting markdown during generation

##### Task-200-30-5-2: Insert tool call markdown format

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`
**Line**: ~116-156 (before executing tool)

**Changes Required**:
```typescript
if (options.editor) {
  const toolCallMarkdown = `\n\n[ðŸ”§ Tool: ${toolCall.name}](mcp://${serverId}/${toolCall.name})\n\`\`\`json\n${JSON.stringify(toolCall.arguments, null, 2)}\n\`\`\`\n`
  options.editor.replaceRange(toolCallMarkdown, options.editor.getCursor())
}
```

**Acceptance Criteria**:
- Given: A tool about to be executed
- When: Inserting tool call into document
- Then: Formatted markdown shows tool name and parameters in code block

##### Task-200-30-5-3: Insert tool result markdown

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`
**Line**: ~116-156 (after executing tool)

**Changes Required**:
```typescript
if (options.editor) {
  const resultMarkdown = `\n**Result** (${result.executionDuration}ms):\n<details>\n<summary>View Result</summary>\n\n\`\`\`json\n${JSON.stringify(result.content, null, 2)}\n\`\`\`\n</details>\n`
  options.editor.replaceRange(resultMarkdown, options.editor.getCursor())
}
```

**Acceptance Criteria**:
- Given: A tool execution completed
- When: Inserting result into document
- Then: Shows duration, content type, and collapsible result

#### UserStory-200-30-10: Format Tool Results

**Priority**: P1
**Story Points**: Î£(8)=8
**Description**: As a user, I need tool results formatted clearly so that I can easily understand what data the tool returned.

##### Task-200-30-10-1: Design result markdown template

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Template Design**:
```markdown
[ðŸ”§ Tool: tool_name](mcp://server-id/tool_name)
```json
{ parameters }
```

**Result** (123ms):
<details>
<summary>View Result</summary>

```json
{ result content }
```
</details>
```

**Acceptance Criteria**:
- Given: A tool execution result
- When: Formatting as markdown
- Then: Uses `<details>/<summary>` for collapsible sections

##### Task-200-30-10-2: Handle different content types

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
- JSON content: ````json` syntax
- Text content: ````text` or plain text
- Markdown content: render directly

**Acceptance Criteria**:
- Given: Tool results with JSON, text, or markdown content
- When: Rendering in document
- Then: Appropriate syntax highlighting applied

##### Task-200-30-10-3: Add metadata display

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
- Show execution duration
- Show content type
- Show token usage if available

**Acceptance Criteria**:
- Given: Tool result with metadata
- When: Displaying in document
- Then: Shows duration (ms), content type, and tokens used

### Feature-200-90: Release Validation & Sign-Off

**Priority**: P1
**Story Points**: 2
**Description**: Capture manual verification and approval steps for core feature delivery.

#### UserStory-200-90-5: Human Review & Release Approval

**Priority**: P1
**Story Points**: 2
**Description**: As a release manager, I need documented validation of core features so that stakeholders can approve deployment.

##### Task-200-90-5-1: Execute manual validation checklist and collect approvals

**Story Points**: 2
**Priority**: P1
**Files**: `docs/release-notes.md`, `tests/manual/mcp-core-validation.md` (new)

**Actions Required**:
- Walk through tool persistence, automatic disablement, and Claude flows in staging
- Record observed outputs, screenshots/logs, and reviewer sign-off in release documentation

**Acceptance Criteria**:
- Given: P1 feature work completed
- When: Manual validation checklist is run
- Then: Release notes contain evidence plus approval from designated reviewer before launch

---

## Epic-300: Performance & Resource Management

**Priority**: P1
**Story Points**: Î£(5+3+8+8+2)=26
**Status**: Not Started
**Description**: Optimize performance and prevent resource leaks in the MCP integration.

**Dependencies**: Epic-100, Epic-200
**Risk**: Low-Medium - affects performance but not core functionality

### Feature-300-10: Tool Discovery Caching

**Priority**: P1
**Story Points**: Î£(3+2)=5
**Description**: Cache tool server mappings to reduce redundant async calls on every request.

**Files Affected**:
- `src/mcp/providerAdapters.ts`
- `src/mcp/managerMCPUse.ts`

#### UserStory-300-10-5: Cache Tool Server Mappings

**Priority**: P2
**Story Points**: 3
**Description**: As a system, I need to cache `buildToolServerMapping` results so that I don't make redundant tool listing calls on every request.

##### Task-300-10-5-1: Add cache Map to provider adapters

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
export class OpenAIProviderAdapter implements ProviderAdapter<OpenAI.ChatCompletionChunk> {
  private toolMapping: Map<string, string> = new Map()

  async initialize(): Promise<void> {
    this.toolMapping = await buildToolServerMapping(this.mcpManager)
  }

  async buildTools() {
    // Use cached this.toolMapping instead of calling buildToolServerMapping again
  }
}
```

**Acceptance Criteria**:
- Given: A `ProviderAdapter` class
- When: Adding `toolMapping` cache
- Then: Cached on `initialize()`, reused in `buildTools()`

##### Task-300-10-5-2: Invalidate cache on server changes

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
- Listen for `server-started`, `server-stopped` events
- Clear cache when configuration changes

**Acceptance Criteria**:
- Given: A server is enabled or disabled
- When: Configuration changes
- Then: Tool mapping cache is cleared and rebuilt on next request

##### Task-300-10-5-3: Add cache metrics

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
- Track cache hits/misses
- Log to console in development mode

**Acceptance Criteria**:
- Given: Tool mapping cache in use
- When: Tracking usage
- Then: Logs cache hit/miss ratio for debugging

#### UserStory-300-10-10: Optimize Tool Listing

**Priority**: P2
**Story Points**: 2
**Description**: As a system, I need to reduce redundant async calls during tool discovery so that performance improves.

##### Task-300-10-10-1: Batch tool listing requests

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Acceptance Criteria**:
- Given: Multiple provider adapters initializing
- When: Calling `buildToolServerMapping`
- Then: Single shared call instead of multiple parallel calls

##### Task-300-10-10-2: Add lazy initialization option

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Acceptance Criteria**:
- Given: A provider adapter created
- When: No immediate tool usage needed
- Then: Defer tool discovery until first request

### Feature-300-20: Memory Leak Prevention

**Priority**: P1
**Story Points**: 3
**Description**: Ensure proper cleanup of active executions on all error paths to prevent memory leaks.

**Files Affected**:
- `src/mcp/executor.ts`
- `tests/mcp/executor.test.ts`

#### UserStory-300-20-5: Fix Execution Cleanup

**Priority**: P1
**Story Points**: 3
**Description**: As a system, I need to ensure `activeExecutions` is cleaned up on ALL error paths so that memory doesn't leak during errors.

##### Task-300-20-5-1: Audit error paths in executor

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/executor.ts`

**Action Items**:
- Review all methods in `ToolExecutor`
- Identify all error paths
- Document paths that might skip cleanup

**Acceptance Criteria**:
- Given: All executor methods
- When: Reviewing error handling
- Then: Documented all paths that might skip `activeExecutions.delete()`

##### Task-300-20-5-2: Add cleanup to error handlers

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Ensure `finally` blocks handle cleanup
- Add try-catch around cleanup code itself
- Use `executionRecord.requestId` for guaranteed cleanup

**Acceptance Criteria**:
- Given: Error occurring in `executeTool`
- When: Exception is thrown
- Then: `activeExecutions.delete()` is still called in finally block

##### Task-300-20-5-3: Add memory leak detection tests

**Story Points**: 1
**Priority**: P2
**File**: `tests/mcp/executor.test.ts`

**Test Cases**:
1. Force 100 failed executions
2. Check `activeExecutions.size` remains 0
3. Verify no unbounded growth

**Acceptance Criteria**:
- Given: Test with 100+ forced errors
- When: Running executions
- Then: `activeExecutions` size stays bounded (doesn't grow indefinitely)

### Feature-300-40: Error Recovery Mechanism

**Priority**: P1
**Story Points**: Î£(8)=8
**Description**: Add exponential backoff retry for transient failures so servers can recover automatically.

**Files Affected**:
- `src/mcp/managerMCPUse.ts`
- `src/settingTab.ts` (for retry config UI)

#### UserStory-300-30-5: Exponential Backoff Retry

**Priority**: P1
**Story Points**: 8
**Description**: As a user, I need transient server failures to be retried automatically with exponential backoff so that temporary network issues don't permanently disable servers.

##### Task-300-30-5-1: Add RetryPolicy configuration

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
```typescript
interface RetryPolicy {
  maxRetries: number        // default: 3
  initialDelay: number      // default: 1000ms
  maxDelay: number          // default: 30000ms
  backoffMultiplier: number // default: 2
}
```

**Acceptance Criteria**:
- Given: Server configuration
- When: Adding retry settings
- Then: `maxRetries`, `initialDelay`, `maxDelay` are configurable

##### Task-300-30-5-2: Implement exponential backoff

**Story Points**: 2
**Priority**: P2
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
```typescript
async startServerWithRetry(serverId: string): Promise<void> {
  let delay = this.retryPolicy.initialDelay

  for (let attempt = 0; attempt <= this.retryPolicy.maxRetries; attempt++) {
    try {
      await this.startServer(serverId)
      return // Success
    } catch (error) {
      if (attempt < this.retryPolicy.maxRetries && this.isTransientError(error)) {
        await sleep(delay)
        delay = Math.min(delay * this.retryPolicy.backoffMultiplier, this.retryPolicy.maxDelay)
      } else {
        throw error
      }
    }
  }
}
```

**Acceptance Criteria**:
- Given: A failed server start
- When: Retrying with backoff
- Then: Delay increases exponentially (1s, 2s, 4s, 8s) up to max

##### Task-300-30-5-3: Classify transient vs permanent errors

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
```typescript
isTransientError(error: Error): boolean {
  // Network errors â†’ retry
  if (error.message.includes('ECONNREFUSED')) return true
  if (error.message.includes('ETIMEDOUT')) return true

  // Config errors â†’ don't retry
  if (error.message.includes('not found in config')) return false
  if (error.message.includes('invalid command')) return false

  return false // Default: don't retry unknown errors
}
```

**Acceptance Criteria**:
- Given: A server startup error
- When: Analyzing error type
- Then: Network errors are retried, configuration errors are not

##### Task-300-30-5-4: Add retry status to UI

**Story Points**: 1
**Priority**: P1
**File**: `src/settingTab.ts`

**Changes Required**:
- Show retry countdown in server status
- Display "Retrying in 4s..." during backoff
- Show attempt count "Attempt 2/3"

**Acceptance Criteria**:
- Given: A server in retry backoff
- When: Viewing status in settings UI
- Then: Shows "Retrying in 4s... (Attempt 2/3)"

##### Task-300-30-5-5: Add retry/backoff unit tests

**Story Points**: 2
**Priority**: P1
**File**: `tests/mcp/managerMCPUse.test.ts`

**Test Cases**:
1. Transient errors retry up to `maxRetries` with exponential delays
2. Non-transient errors stop immediately and surface to caller
3. Retry policy caps delay at configured `maxDelay`

**Acceptance Criteria**:
- Given: The retry implementation with configurable policy
- When: Running the new unit tests
- Then: Transient errors demonstrate the expected retry/backoff behavior and fatal errors bail out after the first attempt

### Feature-300-90: Release Validation & Sign-Off

**Priority**: P1
**Story Points**: 2
**Description**: Document manual validation for resilience and performance improvements before deployment.

#### UserStory-300-90-5: Human Review & Release Approval

**Priority**: P1
**Story Points**: 2
**Description**: As a release manager, I need backoff, caching, and cleanup changes verified manually so that production stability is protected.

##### Task-300-90-5-1: Execute manual resilience checklist and record approval

**Story Points**: 2
**Priority**: P1
**Files**: `docs/release-notes.md`, `tests/manual/mcp-resilience-validation.md` (new)

**Actions Required**:
- Run scripted manual checks for cache invalidation, execution cleanup, and retry backoff in staging
- Attach evidence plus reviewer initials in release documentation

**Acceptance Criteria**:
- Given: Performance and resilience features merged
- When: Manual checklist is completed
- Then: Release notes capture outcomes and reviewer approval prior to release

---

## Epic-400: User Experience Enhancements

**Priority**: P2
**Story Points**: Î£(8+8+5+2)=23
**Status**: Not Started
**Description**: Improve user experience for discovering and using MCP tools.

**Dependencies**: Epic-100, Epic-200
**Risk**: Low - purely UX improvements, no breaking changes

### Feature-400-10: Tool Browser Modal

**Priority**: P2
**Story Points**: 8
**Description**: Create a modal UI to browse all available MCP tools across servers, with search and insert capabilities.

**Files Affected**:
- `src/modals/toolBrowserModal.ts` (new)
- `src/main.ts` (register command)

#### UserStory-400-10-5: Create Tool Browser UI

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need a way to browse all available MCP tools so that I can discover what tools are available and how to use them.

##### Task-400-10-5-1: Create ToolBrowserModal class

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts` (new)

**Changes Required**:
```typescript
export class ToolBrowserModal extends Modal {
  constructor(app: App, mcpManager: MCPServerManager) {
    super(app)
    this.mcpManager = mcpManager
  }

  onOpen() {
    this.contentEl.createEl('h2', { text: 'Browse MCP Tools' })
    // Server selector, tool list, search
  }
}
```

**Acceptance Criteria**:
- Given: Modal class extending `Obsidian.Modal`
- When: Opening the modal
- Then: Shows a list of all servers and their tools

##### Task-400-10-5-2: Add server filter dropdown

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
- Add dropdown with all server names
- "All Servers" option to show everything
- Filter tool list based on selection

**Acceptance Criteria**:
- Given: Multiple servers available
- When: Selecting a server in dropdown
- Then: Tool list filters to show only that server's tools

##### Task-400-10-5-3: Render tool cards

**Story Points**: 2
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Card Layout**:
```html
<div class="tool-card">
  <h3>tool_name</h3>
  <p class="tool-description">Description...</p>
  <details>
    <summary>Parameters</summary>
    <ul>
      <li><strong>param1</strong> (string, required): Description</li>
    </ul>
  </details>
  <button>Insert Code Block</button>
</div>
```

**Acceptance Criteria**:
- Given: A tool from an MCP server
- When: Rendering in the modal
- Then: Shows name, description, and expandable parameter schema

##### Task-400-10-5-4: Add search/filter functionality

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
- Add search input at top
- Filter tools by name/description in real-time
- Highlight matching text

**Acceptance Criteria**:
- Given: Search input in modal
- When: Typing a tool name or keyword
- Then: Tool list filters in real-time to show matches

#### UserStory-400-10-10: Tool Insert Actions

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need to insert tool code blocks from the browser so that I don't have to manually type the syntax.

##### Task-400-10-10-1: Add "Insert Code Block" button

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
- Add button to each tool card
- On click, close modal and insert code block at cursor

**Acceptance Criteria**:
- Given: A tool card in the browser
- When: Clicking "Insert Code Block"
- Then: Code block template is inserted at cursor position

##### Task-400-10-10-2: Generate parameter templates

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Template Format**:
````markdown
```server-name
tool: tool_name
param1:
param2:
```
````

**Acceptance Criteria**:
- Given: A tool with a parameter schema
- When: Generating the template
- Then: Includes all parameters with placeholder values or examples

##### Task-400-10-10-3: Add command palette integration

**Story Points**: 1
**Priority**: P2
**File**: `src/main.ts`

**Changes Required**:
```typescript
this.addCommand({
  id: 'browse-mcp-tools',
  name: 'Browse MCP Tools',
  callback: () => {
    new ToolBrowserModal(this.app, this.mcpManager).open()
  }
})
```

**Acceptance Criteria**:
- Given: Command palette open
- When: Typing "Browse MCP Tools"
- Then: Command appears and opens the tool browser modal

### Feature-400-20: Tool Auto-Completion

**Priority**: P2
**Story Points**: 8
**Description**: Add auto-completion for tool names and parameters in code blocks.

**Files Affected**:
- `src/suggests/mcpToolSuggest.ts` (new)
- `src/suggests/mcpParameterSuggest.ts` (new)
- `src/main.ts` (register suggests)

#### UserStory-400-20-5: Tool Name Auto-Complete

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need auto-completion when typing tool names so that I don't have to remember exact tool names.

##### Task-400-20-5-1: Create MCPToolSuggest class

**Story Points**: 2
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts` (new)

**Changes Required**:
```typescript
export class MCPToolSuggest extends EditorSuggest<ToolSuggestion> {
  onTrigger(cursor: EditorPosition, editor: Editor): EditorSuggestTriggerInfo | null {
    const line = editor.getLine(cursor.line)
    if (line.startsWith('tool:')) {
      const partial = line.substring(5).trim()
      return { start: { line: cursor.line, ch: 5 }, end: cursor, query: partial }
    }
    return null
  }

  async getSuggestions(context: EditorSuggestContext): Promise<ToolSuggestion[]> {
    // Return matching tools
  }
}
```

**Acceptance Criteria**:
- Given: An `EditorSuggest` subclass
- When: Typing in a code block after `tool:`
- Then: Suggests available tool names for that server

##### Task-400-20-5-2: Detect code block context

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts`

**Changes Required**:
- Parse code fence to get server name
- Only suggest tools from that server
- Handle invalid/unknown server names gracefully

**Acceptance Criteria**:
- Given: Cursor inside a code block with fence ```server-name```
- When: Checking context
- Then: Identifies server name and filters suggestions accordingly

##### Task-400-20-5-3: Fetch tools for server

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts`

**Changes Required**:
- Use `mcpManager.getToolsForServer(serverName)`
- Cache tools per server
- Handle server not running errors

**Acceptance Criteria**:
- Given: A server name identified from code fence
- When: Getting suggestions
- Then: Returns only tools from that server

##### Task-400-20-5-4: Render suggestions with descriptions

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts`

**Suggestion Render**:
```
tool_name
Brief description of what this tool does
```

**Acceptance Criteria**:
- Given: Tool suggestions to display
- When: Rendering in suggestion list
- Then: Shows tool name prominently and description below

#### UserStory-400-20-10: Parameter Auto-Complete

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need auto-completion for parameter names so that I know what parameters each tool expects.

##### Task-400-20-10-1: Create MCPParameterSuggest class

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpParameterSuggest.ts` (new)

**Changes Required**:
```typescript
export class MCPParameterSuggest extends EditorSuggest<ParameterSuggestion> {
  onTrigger(cursor: EditorPosition, editor: Editor) {
    // Detect parameter line
    // Get tool name from earlier in block
    // Suggest parameters
  }
}
```

**Acceptance Criteria**:
- Given: An `EditorSuggest` subclass for parameters
- When: Typing a parameter line in code block
- Then: Suggests parameter names for the current tool

##### Task-400-20-10-2: Parse parameter schema

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpParameterSuggest.ts`

**Changes Required**:
- Extract parameter info from tool schema
- Get name, type, required status, description
- Show examples if available

**Acceptance Criteria**:
- Given: A tool schema with parameters
- When: Extracting parameter info
- Then: Returns name, type, required flag, and description

##### Task-400-20-10-3: Show parameter metadata

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpParameterSuggest.ts`

**Suggestion Render**:
```
param_name (string) *
Description of parameter
```

**Acceptance Criteria**:
- Given: Parameter suggestions
- When: Rendering
- Then: Shows type in parentheses, `*` for required params

### Feature-400-30: Enhanced Status Display

**Priority**: P2
**Story Points**: 5
**Description**: Improve status bar and modal with real-time updates and detailed metrics.

**Files Affected**:
- `src/statusBarManager.ts`
- `src/modals/mcpStatusModal.ts`

#### UserStory-400-30-5: Real-Time Status Updates

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need real-time status updates so that I can see server state changes immediately.

##### Task-400-30-5-1: Listen to manager events

**Story Points**: 1
**Priority**: P2
**File**: `src/statusBarManager.ts`

**Changes Required**:
```typescript
mcpManager.on('server-started', () => this.updateMCPStatus())
mcpManager.on('server-stopped', () => this.updateMCPStatus())
mcpManager.on('server-failed', () => this.updateMCPStatus())
```

**Acceptance Criteria**:
- Given: A server status change event
- When: Event is emitted
- Then: Status bar updates immediately without waiting for next health check

##### Task-400-30-5-2: Add execution count to status

**Story Points**: 1
**Priority**: P2
**File**: `src/statusBarManager.ts`

**Display Format**:
```
Tars | MCP: 2/3 (15 tools, 3 active)
```

**Acceptance Criteria**:
- Given: Tools currently executing
- When: Viewing status bar
- Then: Shows active execution count: "MCP: 2/3 (15 tools, 3 active)"

##### Task-400-30-5-3: Add error indicators

**Story Points**: 1
**Priority**: P2
**File**: `src/statusBarManager.ts`

**Changes Required**:
- Show âš ï¸ icon if any server has errors
- Include error count in tooltip
- Change status bar color on critical errors

**Acceptance Criteria**:
- Given: A server in error state
- When: Viewing status bar
- Then: Shows warning icon and error count in tooltip

#### UserStory-400-30-10: Enhanced Status Modal

**Priority**: P2
**Story Points**: 2
**Description**: As a user, I need detailed metrics in the status modal so that I can monitor MCP performance.

##### Task-400-30-10-1: Add execution statistics

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/mcpStatusModal.ts`

**Metrics to Show**:
- Total executions
- Average execution duration
- Success rate
- Error rate

**Acceptance Criteria**:
- Given: Status modal open
- When: Viewing server details
- Then: Shows total executions, avg duration, success/error rates

##### Task-400-30-10-2: Add refresh button

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/mcpStatusModal.ts`

**Changes Required**:
- Add "Refresh" button to modal
- Re-query server health on click
- Update display without closing modal

**Acceptance Criteria**:
- Given: Status modal open
- When: Clicking refresh button
- Then: Re-queries server health and updates display in place

### Feature-400-90: Release Validation & Sign-Off

**Priority**: P2
**Story Points**: 2
**Description**: Capture UX-focused manual validation before release.

#### UserStory-400-90-5: Human Review & Release Approval

**Priority**: P2
**Story Points**: 2
**Description**: As a release manager, I need UX improvements reviewed in the app so users receive a polished experience.

##### Task-400-90-5-1: Run UX smoke test script and record feedback

**Story Points**: 2
**Priority**: P2
**Files**: `docs/release-notes.md`, `tests/manual/mcp-ux-validation.md` (new)

**Actions Required**:
- Execute manual UX walkthrough covering tool browser, auto-complete, and status display
- Capture screenshots/findings and reviewer initials in release notes

**Acceptance Criteria**:
- Given: UX enhancements shipped in this epic
- When: Manual validation completes
- Then: Release notes include summary, evidence, and reviewer approval

---

## Epic-500: Advanced Features

**Priority**: P3
**Story Points**: Î£(8+8+5+2)=23
**Status**: Not Started
**Description**: Advanced features that enhance power-user workflows and efficiency.

**Dependencies**: Epic-100, Epic-200, Epic-300, Epic-400
**Risk**: Low - optional enhancements, can be deferred

### Feature-500-10: Parallel Tool Execution

**Priority**: P3
**Story Points**: 8
**Description**: Allow multiple tools to execute concurrently when LLM requests multiple tools.

**Files Affected**:
- `src/mcp/toolCallingCoordinator.ts`
- `src/mcp/executor.ts`
- `src/settingTab.ts`

#### UserStory-500-10-5: Implement Parallel Execution

**Priority**: P3
**Story Points**: 5
**Description**: As a power user, I need tools to execute in parallel so that multi-tool workflows complete faster.

##### Task-500-10-5-1: Add parallel execution mode to coordinator

**Story Points**: 2
**Priority**: P3
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
```typescript
if (options.parallelExecution) {
  const toolPromises = toolCalls.map(async (toolCall) => {
    const serverId = adapter.findServerId(toolCall.name)
    return executor.executeTool({ serverId, toolName: toolCall.name, ... })
  })
  const results = await Promise.all(toolPromises)
} else {
  // Existing sequential execution
}
```

**Acceptance Criteria**:
- Given: Multiple tool calls from LLM
- When: `parallelExecution` option is enabled
- Then: Uses `Promise.all()` instead of sequential `await`

##### Task-500-10-5-2: Add execution synchronization

**Story Points**: 2
**Priority**: P3
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Use mutex/semaphore for `activeExecutions` Set operations
- Ensure concurrent limit is enforced across parallel executions
- Thread-safe cleanup

**Acceptance Criteria**:
- Given: Parallel tool execution
- When: Tracking active executions
- Then: Properly synchronizes updates to `activeExecutions` Set

##### Task-500-10-5-3: Handle partial failures

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
- Catch errors per-tool in parallel execution
- Return successful results even if some fail
- Log failures without stopping other tools

**Acceptance Criteria**:
- Given: 3 tools executing in parallel
- When: 1 fails and 2 succeed
- Then: Successful results are returned, error is logged but doesn't block

#### UserStory-500-10-10: Configuration & Safety

**Priority**: P3
**Story Points**: Î£(5)=5
**Description**: As an administrator, I need to configure parallel execution limits so that resource usage is controlled.

##### Task-500-10-10-1: Add parallelExecution setting

**Story Points**: 1
**Priority**: P3
**File**: `src/settingTab.ts`

**UI Element**:
```typescript
new Setting(containerEl)
  .setName('Enable parallel tool execution')
  .setDesc('Allow multiple tools to execute concurrently (experimental)')
  .addToggle(toggle => toggle
    .setValue(settings.parallelExecution ?? false)
    .onChange(async (value) => { ... })
  )
```

**Acceptance Criteria**:
- Given: Settings UI
- When: Adding parallel execution toggle
- Then: Defaults to `false` for safety

##### Task-500-10-10-2: Add max parallel limit

**Story Points**: 1
**Priority**: P3
**File**: `src/settingTab.ts`

**Changes Required**:
- Add numeric input for max parallel executions
- Enforce limit in coordinator
- Default to concurrentLimit setting

**Acceptance Criteria**:
- Given: Parallel execution enabled
- When: LLM requests 10 tools
- Then: Only executes `concurrentLimit` at once, queues the rest

##### Task-500-10-10-3: Add parallel execution tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/toolCallingCoordinator.test.ts`

**Test Cases**:
1. Execute 3 tools in parallel
2. Verify all complete correctly
3. Test partial failure handling
4. Verify concurrent limit enforcement

**Acceptance Criteria**:
- Given: Test with multiple tool calls
- When: Running in parallel mode
- Then: All tools execute, results are correct, errors handled

### Feature-500-20: Tool Result Caching

**Priority**: P3
**Story Points**: 8
**Description**: Cache tool execution results to avoid redundant calls with same parameters.

**Files Affected**:
- `src/mcp/resultCache.ts` (new)
- `src/mcp/executor.ts`
- `src/settingTab.ts`

#### UserStory-500-20-5: Implement Result Cache

**Priority**: P3
**Story Points**: 3
**Description**: As a user, I need tool results cached so that repeated calls with same parameters use cached data.

##### Task-500-20-5-1: Create ResultCache class

**Story Points**: 2
**Priority**: P3
**File**: `src/mcp/resultCache.ts` (new)

**Implementation**:
```typescript
export class ResultCache {
  private cache: Map<string, CachedResult> = new Map()

  hash(serverId: string, toolName: string, parameters: Record<string, unknown>): string {
    return createHash('sha256')
      .update(JSON.stringify({ serverId, toolName, parameters }))
      .digest('hex')
  }

  get(hash: string): ToolExecutionResult | null { ... }
  set(hash: string, result: ToolExecutionResult, ttl: number): void { ... }
  invalidate(serverId?: string): void { ... }
}
```

**Acceptance Criteria**:
- Given: A tool execution request
- When: Hashing parameters
- Then: Generates stable hash suitable for caching

##### Task-500-20-5-2: Check cache before execution

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/executor.ts`

**Changes Required**:
```typescript
async executeTool(request: ToolExecutionRequest): Promise<ToolExecutionResult> {
  const hash = this.resultCache.hash(request.serverId, request.toolName, request.parameters)
  const cached = this.resultCache.get(hash)
  if (cached) {
    return { ...cached, cached: true }
  }

  // ... existing execution logic
}
```

**Acceptance Criteria**:
- Given: A tool execution request
- When: Checking cache
- Then: Returns cached result if exists and not expired

##### Task-500-20-5-3: Store results with TTL

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Store result after successful execution
- Include timestamp and TTL
- Default TTL: 5 minutes

**Acceptance Criteria**:
- Given: A tool execution completed successfully
- When: Storing in cache
- Then: Includes timestamp and configurable TTL

##### Task-500-20-5-4: Add cache invalidation

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/resultCache.ts`

**Invalidation Triggers**:
- TTL expired (automatic)
- Manual clear command
- Server restart (clear that server's cache)

**Acceptance Criteria**:
- Given: Cached results with expired TTL
- When: Checking cache
- Then: Expired results are removed and not returned

#### UserStory-500-20-10: Cache UI Integration

**Priority**: P3
**Story Points**: 3
**Description**: As a user, I need to see cache status so that I know when results are from cache vs fresh execution.

##### Task-500-20-10-1: Add cache indicator to results

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/toolCallingCoordinator.ts`

**Display Format**:
```markdown
**Result** (123ms) ðŸ“¦ Cached (2m ago)
```

**Acceptance Criteria**:
- Given: A tool result from cache
- When: Displaying in document
- Then: Shows "ðŸ“¦ Cached" with age

##### Task-500-20-10-2: Add cache management command

**Story Points**: 1
**Priority**: P3
**File**: `src/main.ts`

**Command**:
```typescript
this.addCommand({
  id: 'clear-mcp-cache',
  name: 'Clear MCP Tool Result Cache',
  callback: () => {
    this.mcpExecutor.resultCache.clear()
    new Notice('MCP cache cleared')
  }
})
```

**Acceptance Criteria**:
- Given: Command palette open
- When: Typing "Clear MCP Cache"
- Then: Clears all cached tool results

##### Task-500-20-10-3: Add cache statistics

**Story Points**: 1
**Priority**: P3
**File**: `src/modals/mcpStatusModal.ts`

**Metrics**:
- Cache hit rate (%)
- Cache size (MB)
- Number of entries
- Oldest entry age

**Acceptance Criteria**:
- Given: Status modal open
- When: Viewing cache section
- Then: Shows hit rate, size, entry count

### Feature-500-30: Execution History Viewer

**Priority**: P3
**Story Points**: Î£(5)=5
**Description**: Modal to view and search past tool executions.

**Files Affected**:
- `src/modals/executionHistoryModal.ts` (new)
- `src/main.ts`

#### UserStory-500-30-5: Build History UI

**Priority**: P3
**Story Points**: 5
**Description**: As a user, I need to view past tool executions so that I can audit and debug tool usage.

##### Task-500-30-5-1: Create ExecutionHistoryModal

**Story Points**: 2
**Priority**: P3
**File**: `src/modals/executionHistoryModal.ts` (new)

**Table Columns**:
- Timestamp
- Server
- Tool Name
- Status (success/error)
- Duration
- Actions (View Details)

**Acceptance Criteria**:
- Given: Execution history data
- When: Opening modal
- Then: Shows table of past executions sorted by timestamp

##### Task-500-30-5-2: Add filters and search

**Story Points**: 2
**Priority**: P3
**File**: `src/modals/executionHistoryModal.ts`

**Filters**:
- Server dropdown
- Tool name search
- Status filter (all/success/error)
- Date range

**Acceptance Criteria**:
- Given: History modal with filters
- When: Filtering by server/tool/status
- Then: Table updates in real-time to show matching entries

##### Task-500-30-5-3: Add detail view

**Story Points**: 1
**Priority**: P3
**File**: `src/modals/executionHistoryModal.ts`

**Detail View Shows**:
- Full parameters (JSON)
- Full result (JSON)
- Metadata (duration, tokens, etc.)
- Error message if failed

**Acceptance Criteria**:
- Given: An execution in the history table
- When: Clicking "View Details"
- Then: Shows expandable panel with parameters, result, and metadata

### Feature-500-90: Release Validation & Sign-Off

**Priority**: P3
**Story Points**: 2
**Description**: Ensure advanced capabilities receive manual acceptance before rollout.

#### UserStory-500-90-5: Human Review & Release Approval

**Priority**: P3
**Story Points**: 2
**Description**: As a release manager, I need advanced workflows sanity-checked so power users can rely on them.

##### Task-500-90-5-1: Run advanced feature validation script and document approval

**Story Points**: 2
**Priority**: P3
**Files**: `docs/release-notes.md`, `tests/manual/mcp-advanced-validation.md` (new)

**Actions Required**:
- Follow manual script covering parallel execution, result caching, and history viewer
- Capture findings and reviewer signature in release notes before release

**Acceptance Criteria**:
- Given: Advanced features are toggled on in staging
- When: Manual validation script completes
- Then: Release documentation shows evidence plus reviewer approval

---

## Epic-600: Testing Infrastructure

**Priority**: P3
**Story Points**: 13
**Status**: Not Started
**Description**: Improve testing infrastructure for better coverage and confidence.

**Dependencies**: Epic-100, Epic-200 (core functionality must exist to test)
**Risk**: Low - improves quality but not user-facing

### Feature-600-10: UI Testing Strategy

**Priority**: P3
**Story Points**: 8
**Description**: Refactor and test UI components without requiring full Obsidian runtime.

**Files Affected**:
- `src/statusBarManager.ts`
- `src/modals/mcpStatusModal.ts`
- `tests/ui/` (new directory)

#### UserStory-600-10-5: Extract Testable UI Logic

**Priority**: P3
**Story Points**: 5
**Description**: As a developer, I need UI logic extracted to pure functions so that I can test without Obsidian API.

##### Task-600-10-5-1: Extract status formatting functions

**Story Points**: 1
**Priority**: P3
**Files**: `src/statusBarManager.ts`, `src/utils/statusFormatting.ts` (new)

**Refactor Example**:
```typescript
// Before:
class StatusBarManager {
  setMCPStatus(status: MCPStatusInfo) {
    this.statusBarItem.setText(`Tars | MCP: ${status.runningServers}/${status.totalServers}`)
  }
}

// After:
// src/utils/statusFormatting.ts
export function formatMCPStatus(status: MCPStatusInfo): string {
  return `Tars | MCP: ${status.runningServers}/${status.totalServers}`
}

// src/statusBarManager.ts
class StatusBarManager {
  setMCPStatus(status: MCPStatusInfo) {
    this.statusBarItem.setText(formatMCPStatus(status))
  }
}
```

**Acceptance Criteria**:
- Given: UI status display logic
- When: Extracting to pure functions in `src/utils/statusFormatting.ts`
- Then: Functions are testable without Obsidian API

##### Task-600-10-5-2: Extract HTML generation functions

**Story Points**: 2
**Priority**: P3
**Files**: `src/modals/mcpStatusModal.ts`, `src/utils/htmlBuilders.ts` (new)

**Refactor Example**:
```typescript
// src/utils/htmlBuilders.ts
export function buildMCPStatusHTML(status: MCPStatusInfo): string {
  return `
    <div class="mcp-status">
      <h2>MCP Status</h2>
      <p>Running: ${status.runningServers}/${status.totalServers}</p>
      <p>Tools: ${status.availableTools}</p>
    </div>
  `
}

// src/modals/mcpStatusModal.ts
class MCPStatusModal extends Modal {
  onOpen() {
    const html = buildMCPStatusHTML(this.mcpStatus)
    this.contentEl.innerHTML = html
  }
}
```

**Acceptance Criteria**:
- Given: Modal content generation logic
- When: Extracting to builder functions
- Then: Returns HTML string that is testable without Obsidian

##### Task-600-10-5-3: Add unit tests for UI logic

**Story Points**: 2
**Priority**: P3
**File**: `tests/ui/statusFormatting.test.ts` (new)

**Test Cases**:
1. `formatMCPStatus` with various inputs
2. `buildMCPStatusHTML` with different server counts
3. Status formatting edge cases (0 servers, all failed, etc.)

**Acceptance Criteria**:
- Given: Extracted UI formatting functions
- When: Running unit tests
- Then: All formatting/generation logic is covered

#### UserStory-600-10-10: Playwright E2E Setup

**Priority**: P3
**Story Points**: 3
**Description**: As a developer, I need E2E tests for critical UI flows so that I can catch integration bugs.

##### Task-600-10-10-1: Install and configure Playwright

**Story Points**: 1
**Priority**: P3
**Files**: `package.json`, `playwright.config.ts` (new)

**Installation**:
```bash
npm install -D @playwright/test
npx playwright install
```

**Config**:
```typescript
// playwright.config.ts
export default defineConfig({
  testDir: './tests/e2e-ui',
  timeout: 30000,
  use: {
    baseURL: 'obsidian://vault/test-vault',
  },
})
```

**Acceptance Criteria**:
- Given: Project dependencies
- When: Installing `@playwright/test`
- Then: Configured for Obsidian app testing with custom protocol

##### Task-600-10-10-2: Create test vault setup script

**Story Points**: 1
**Priority**: P3
**File**: `scripts/setup-test-vault.sh` (new)

**Script Actions**:
1. Create test vault directory
2. Copy plugin build to `.obsidian/plugins/tars`
3. Enable plugin in vault config
4. Populate with sample data

**Acceptance Criteria**:
- Given: Build output in `dist/`
- When: Running setup script
- Then: Test vault created with plugin installed and enabled

##### Task-600-10-10-3: Write sample E2E test

**Story Points**: 1
**Priority**: P3
**File**: `tests/e2e-ui/mcp-settings.spec.ts` (new)

**Sample Test**:
```typescript
import { test, expect } from '@playwright/test'

test('MCP settings panel visible', async ({ page }) => {
  await page.goto('obsidian://vault/test-vault')
  await page.click('[aria-label="Settings"]')
  await page.click('text=Tars')
  await page.click('summary:has-text("MCP Servers")')

  await expect(page.locator('text=Global timeout')).toBeVisible()
  await expect(page.locator('button:has-text("Add Custom MCP Server")')).toBeVisible()
})
```

**Acceptance Criteria**:
- Given: A Playwright test
- When: Opening settings and navigating to MCP section
- Then: Verifies MCP UI elements are visible

### Feature-600-20: Coverage Improvements

**Priority**: P3
**Story Points**: 3
**Description**: Add tests for scenarios not currently covered.

**Files Affected**:
- Various test files

#### UserStory-600-20-5: Missing Test Coverage

**Priority**: P3
**Story Points**: 3
**Description**: As a developer, I need tests for uncovered scenarios so that I have confidence in code changes.

##### Task-600-20-5-1: Add timeout handling tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/executor.test.ts`

**Test Cases**:
1. Tool execution exceeds timeout
2. Timeout error is thrown
3. Execution is cleaned up properly
4. activeExecutions set is updated

**Acceptance Criteria**:
- Given: Tool execution with timeout
- When: Tool exceeds configured timeout
- Then: Error is thrown and execution is cleaned up

##### Task-600-20-5-3: Add health check tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/managerMCPUse.test.ts`

**Test Cases**:
1. Health check updates status correctly
2. Disconnected servers marked unhealthy
3. Health status persists across checks

**Acceptance Criteria**:
- Given: Health check timer running
- When: Checking server health
- Then: Status is updated correctly in health map

##### Task-600-20-5-4: Add error scenario tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/errorHandling.test.ts` (new)

**Error Scenarios**:
1. Server fails to start
2. Tool execution throws error
3. Network timeout
4. Invalid tool parameters
5. Server disconnects during execution

**Acceptance Criteria**:
- Given: Various error conditions
- When: Running tests
- Then: All error paths are tested and handled correctly

### Feature-600-90: Release Validation & Sign-Off

**Priority**: P3
**Story Points**: 2
**Description**: Document manual confirmation of testing infrastructure updates.

#### UserStory-600-90-5: Human Review & Release Approval

**Priority**: P3
**Story Points**: 2
**Description**: As a release manager, I need confirmation that testing tooling changes work so the team can rely on the new workflows.

##### Task-600-90-5-1: Verify test tooling updates and capture approval

**Story Points**: 2
**Priority**: P3
**Files**: `docs/release-notes.md`, `tests/manual/testing-tooling-validation.md` (new)

**Actions Required**:
- Run representative UI, integration, and Playwright suites in CI/staging
- Record outcomes and reviewer sign-off in release documentation

**Acceptance Criteria**:
- Given: Testing infrastructure adjustments implemented
- When: Manual verification completes
- Then: Release notes include execution evidence and reviewer approval

---

## Summary & Timeline

### Overview by Epic

| Epic | Priority | Story Points | Estimated Duration | Dependencies |
|------|----------|--------------|-------------------|--------------|
| Epic-100: Critical Bug Fixes | P0 | Î£=16 | 3-4 days | None |
| Epic-200: Core Missing Features | P1 | Î£=28 | 1.5-2 weeks | Epic-100 |
| Epic-300: Performance & Resource Management | P1 | Î£=26 | 1.5 weeks | Epic-100, Epic-200 |
| Epic-400: User Experience | P2 | Î£=23 | 1-1.5 weeks | Epic-100, Epic-200 |
| Epic-500: Advanced Features | P3 | Î£=23 | 1-1.5 weeks | Epic-100-400 |
| Epic-600: Testing Infrastructure | P3 | Î£=13 | 4-5 days | Epic-100, Epic-200 |
| Epic-700: Settings UI Improvements | P2 | Î£=18 | 1 week | Epic-200 |
| Epic-900: Document-Scoped Sessions & Enhanced UX | P1 | Î£=31 | 1.5-2 weeks | Epic-100, Epic-200, Epic-400 |

**Total Story Points**: Î£=178
**Estimated Timeline**: 8-10 weeks for full implementation

### Priority Breakdown

- **P0 (Blockers)**: Î£=16 points (~3-4 days) - Must fix before any release
- **P1 (Critical)**: Î£=85 points (~4-5 weeks) - Required for complete feature set, resilience, and improved workflows
- **P2 (Important)**: Î£=41 points (~2-2.5 weeks) - Greatly improves UX, discoverability, and settings management
- **P3 (Nice to have)**: Î£=36 points (~1.5-2 weeks) - Advanced features and infrastructure polish

### Recommended Implementation Phases

#### Phase 1: Stabilization (P0) - Week 1
**Goal**: Fix production blockers, make MCP integration functional

- Epic-100: Critical Bug Fixes (Î£=16 pts)
  - Fix ID/name mismatch
  - Enable settings (timeout, limits)
  - Activate health monitoring
  - Complete manual release validation & approval

**Outcome**: MCP integration works reliably, settings are respected

#### Phase 2: Core Completeness (P1) - Weeks 2-3
**Goal**: Complete missing core features

- Epic-200: Core Missing Features (Î£=28 pts)
  - Auto-disable failed servers
  - Claude provider integration
  - Tool result persistence in documents
  - Conduct manual validation & release approval

**Outcome**: Full provider coverage, tool results visible, better reliability

#### Phase 3: Resilience & Optimization (P1) - Weeks 3-4
**Goal**: Improve reliability, performance, and recovery

- Epic-300: Performance & Resource Management (Î£=18 pts)
  - Tool discovery caching
  - Memory leak prevention
  - Error recovery with retry and status updates
  - Complete resilience release validation & approval

**Outcome**: Better performance, fewer resource issues

#### Phase 4: User Experience (P2) - Weeks 4-5
**Goal**: Make MCP tools discoverable and easy to use

- Epic-400: User Experience Enhancements (Î£=23 pts)
  - Tool browser modal
  - Auto-completion
  - Enhanced status display
  - Run UX smoke validation & secure approval

**Outcome**: Users can easily discover and use tools

#### Phase 5: Document-Scoped Workflows (P1) - Weeks 6-7
**Goal**: Improve session management and user workflows

- Epic-900: Document-Scoped Sessions & Enhanced UX (Î£=31 pts)
  - Document-scoped session tracking
  - Smart tool result caching
  - Collapsible settings sections
  - Enhanced display mode toggle
  - Status bar improvements with session counts
  - Unified tool result formatting

**Outcome**: Better session isolation, cached results prevent redundant executions, improved settings organization

#### Phase 6: Advanced Features (P3) - Week 8
**Goal**: Power-user features (optional)

- Epic-500: Advanced Features (Î£=23 pts)
  - Parallel tool execution
  - Result caching
  - Execution history viewer
  - Perform advanced workflow validation & approval

**Outcome**: Advanced workflows enabled

#### Phase 7: Settings UI Refinement (P2) - Week 8
**Goal**: Improve settings maintainability

- Epic-700: Settings UI Improvements (Î£=18 pts)
  - Config display mode toggle
  - Refactor settings UI architecture
  - Component-based structure

**Outcome**: More maintainable settings code, better user affordances

#### Phase 8: Quality Assurance (P3) - Week 9
**Goal**: Improve test coverage

- Epic-600: Testing Infrastructure (Î£=13 pts)
  - UI testing strategy
  - Coverage improvements
  - Validate tooling updates & capture approval

**Outcome**: Higher confidence in changes

---

## Epic-700: Settings UI Improvements

**Priority**: P2
**Story Points**: Î£(5+13)=18
**Status**: Not Started
**Description**: Improve Settings UI for MCP server configuration. The current settingTab.ts is large (~1000+ lines) and complex, making it difficult to maintain and extend. The UI needs better affordances for showing URLâ†’JSON conversion and switching between input modes.

**Dependencies**: Epic-200 (should have core features working first)

### Feature-700-10: Add Config Display Mode Toggle

**Priority**: P2
**Story Points**: 5
**Description**: Add UI to toggle between "simple" and "advanced" view for MCP server configs, showing how URLs are converted to mcp-remote commands.

**Files Affected**:
- `src/settingTab.ts`
- `src/settings.ts` (add display preference)

#### UserStory-700-10-5: Implement Config View Toggle

**Priority**: P2
**Story Points**: 5
**Description**: As a user configuring MCP servers, I want to see how my URL is converted to a command so I understand what's happening under the hood.

**Acceptance Criteria**:
- Given: User enters a URL for MCP server config
- When: User toggles to "Show as Command" view
- Then: UI displays the equivalent `npx -y mcp-remote <url>` command
- And: User can toggle back to simple URL view
- And: Both views are editable and stay in sync

**Implementation Notes**:
- Add toggle button/switch next to each server config
- Show computed command in read-only or editable format
- Preserve user's view preference per server or globally
- Update on input change to show live conversion

### Feature-700-20: Refactor Settings UI Architecture

**Priority**: P2
**Story Points**: 13
**Description**: Refactor settingTab.ts to be more maintainable. Consider React migration or at least extract server config UI into separate component/file.

**Files Affected**:
- `src/settingTab.ts` (split into smaller files)
- New: `src/settings/` directory structure

#### UserStory-700-20-5: Extract MCP Settings to Separate Component

**Priority**: P2
**Story Points**: 8
**Description**: As a developer, I want MCP server settings UI separated from main settings tab so it's easier to maintain and test.

**Acceptance Criteria**:
- Given: Current monolithic settingTab.ts
- When: Refactoring is complete
- Then: MCP server UI is in separate file(s)
- And: Each component is <300 lines
- And: All existing functionality preserved
- And: UI tests can be written for components

**Implementation Options**:
1. **Vanilla extraction**: Move to `src/settings/MCPServerSettings.ts` using existing Obsidian API
2. **React migration**: Use React components with Obsidian wrapper (more complex)
3. **Web Components**: Use standard web components (middle ground)

**Recommendation**: Start with vanilla extraction (option 1) as it's lower risk and maintains existing patterns.

#### UserStory-700-20-10: Add Component Tests for Settings UI

**Priority**: P2
**Story Points**: 5
**Description**: As a developer, I want tests for settings UI logic so I can refactor confidently.

**Acceptance Criteria**:
- Given: Extracted settings components
- When: Running test suite
- Then: Settings UI logic is tested (validation, conversion, state management)
- And: Tests don't require full Obsidian environment (use mocks)
- And: Coverage >80% for settings logic

**Test Cases**:
1. URL to command conversion display
2. Config validation (empty, invalid URL, invalid JSON)
3. Server enable/disable toggle
4. Server add/remove
5. Config persistence

**Outcome**: Higher confidence in changes

### Notes for LLM Implementers

1. **Start with Phase 1** (Epic-100) - don't skip these blockers
2. **Test thoroughly** - each task has acceptance criteria that define tests
3. **Update this document** - mark completed items, add discovered work
4. **Ask for clarification** - if acceptance criteria are unclear
5. **Follow existing patterns** - maintain consistency with current code style
6. **Document changes** - update relevant docs when adding features

### Cross-Reference Links

- **Original Review**: [2025-10-03-mcp-integration-review.md](2025-10-03-mcp-integration-review.md)
- **Codebase Root**: `src/`
- **Test Root**: `tests/`
- **Settings**: `src/settingTab.ts`
- **Main Plugin**: `src/main.ts`
- **MCP Core**: `src/mcp/`

---

## Epic-900: Document-Scoped Sessions & Enhanced UX

**Priority**: P1
**Story Points**: Î£(8+5+5+8+3+2)=31
**Status**: Not Started
**Description**: Improve session management, tool execution UX, and settings organization based on user workflow requirements. Session limits should apply per-document instead of globally, tool results should be cached intelligently, and UI should provide better affordances for session management and tool re-execution.

**Dependencies**: Epic-100, Epic-200, Epic-400 (core features must exist)
**Risk**: Medium - changes session lifecycle and document interaction patterns

### Feature-900-10: Document-Scoped Session Management

**Priority**: P1
**Story Points**: 8
**Description**: Session limits should apply per-document, not globally. Switching documents resets session context to allow independent work across multiple notes.

**Clarifications**:
- **Q1 Answer (Session Scope)**: All servers share one total counter per document
  - Example: Document A â†’ total: 8 sessions (across all servers)
  - Example: Document B â†’ total: 0 sessions
- **Q2 Answer (Session Persistence)**: Reset to 0 (fresh start every time document opens)
  - Show notification that counter reset when document is reopened
- **Q9 Answer (Reset Scope)**: Reset counter to 0 for current document only

**Files Affected**:
- `src/mcp/executor.ts`
- `src/editor.ts`
- `src/main.ts`

#### UserStory-900-10-5: Per-Document Session Tracking

**Priority**: P1
**Story Points**: 8
**Description**: As a user, I need session limits to apply per-document so that switching notes doesn't exhaust my session budget.

**Acceptance Criteria**:
- Given: User has session limit of 25
- When: User switches from Note A to Note B
- Then: Session counter resets to 0 for Note B
- And: Each document maintains independent session state (total across all servers)
- And: Session state resets to 0 when document is closed/reopened
- And: User sees notification when counter resets on document reopen

##### Task-900-10-5-1: Add document-scoped session tracker

**Story Points**: 3
**Priority**: P1
**File**: `src/mcp/executor.ts`

**Changes Required**:
```typescript
interface DocumentSessionState {
  documentPath: string
  totalSessionCount: number // TOTAL count across all servers (Q1 Answer)
  lastAccessed: number
}

class ToolExecutor {
  private documentSessions: Map<string, DocumentSessionState> = new Map()

  // Get total session count for document (across all servers)
  getTotalSessionCount(documentPath: string): number {
    const docState = this.documentSessions.get(documentPath)
    return docState?.totalSessionCount ?? 0
  }

  // Increment total session count (not per-server)
  incrementSessionCount(documentPath: string): void {
    let docState = this.documentSessions.get(documentPath)
    if (!docState) {
      docState = {
        documentPath,
        totalSessionCount: 0,
        lastAccessed: Date.now()
      }
      this.documentSessions.set(documentPath, docState)
    }

    docState.totalSessionCount += 1
    docState.lastAccessed = Date.now()
  }

  // Reset total session count for document (Q9 Answer)
  resetSessionCount(documentPath: string): void {
    const docState = this.documentSessions.get(documentPath)
    if (docState) {
      docState.totalSessionCount = 0
    }
  }

  // Switch to different document context
  switchDocument(newPath: string): void {
    // Called when active editor changes
    // Session state automatically switches context
  }

  // Clear session state when document closes (Q2 Answer)
  clearDocumentSession(documentPath: string): void {
    this.documentSessions.delete(documentPath)
  }
}
```

**Acceptance Criteria**:
- Given: Multiple documents open
- When: Tracking session counts
- Then: Each document has independent TOTAL counter (not per-server, across all servers)
- And: Session counts persist while document is open
- And: Session counts reset to 0 when document is closed/reopened (Q2 Answer)
- And: User sees notification when counter resets on document reopen (Q2 Answer)

##### Task-900-10-5-2: Detect document switch and update context

**Story Points**: 2
**Priority**: P1
**File**: `src/main.ts`

**Changes Required**:
```typescript
// In plugin onload:
this.registerEvent(
  this.app.workspace.on('active-leaf-change', (leaf) => {
    if (leaf?.view?.getViewType() === 'markdown') {
      const file = this.app.workspace.getActiveFile()
      if (file) {
        this.mcpExecutor.switchDocument(file.path)
      }
    }
  })
)

// On file close, clean up session state
this.registerEvent(
  this.app.vault.on('delete', (file) => {
    this.mcpExecutor.clearDocumentSession(file.path)
  })
)
```

**Acceptance Criteria**:
- Given: User switches from doc A to doc B
- When: Editor active file changes
- Then: Executor session context switches to doc B
- And: Session state for doc A is preserved until file closed

##### Task-900-10-5-3: Add session reset notification UI

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/executor.ts`

**Changes Required**:
```typescript
async showSessionLimitReached(
  documentPath: string
): Promise<boolean> {
  return new Promise((resolve) => {
    const notice = new Notice('', 0) // Don't auto-dismiss

    notice.noticeEl.createDiv({ cls: 'mcp-session-notice' }, (container) => {
      container.createEl('p', {
        text: `Session limit reached for this document (total across all servers).`
      })

      const actions = container.createDiv({ cls: 'mcp-session-actions' })

      actions.createEl('button', { text: 'Continue', cls: 'mod-cta' })
        .addEventListener('click', () => {
          this.resetSessionCount(documentPath)
          notice.hide()
          resolve(true)
        })

      actions.createEl('button', { text: 'Cancel' })
        .addEventListener('click', () => {
          notice.hide()
          resolve(false)
        })
    })
  })
}

// Also add notification for document reopen (Q2 Answer)
showSessionResetNotification(documentPath: string): void {
  new Notice(`Session counter reset for this document`, 3000)
}
```

**Acceptance Criteria**:
- Given: Session limit reached for current document (total across all servers)
- When: User attempts another tool execution
- Then: Notice shown with "Continue" and "Cancel" buttons
- And: Clicking Continue resets total counter for that document (Q9 Answer)
- And: Clicking Cancel prevents execution
- And: Document reopen shows notification that counter was reset (Q2 Answer)

##### Task-900-10-5-4: Add tests for document-scoped sessions

**Story Points**: 1
**Priority**: P1
**File**: `tests/mcp/executor.test.ts`

**Test Cases**:
1. Session count increments per document independently (total across all servers)
2. Switching documents maintains separate total counters
3. Session reset affects only specified document (not all documents - Q9)
4. Document close cleans up session state
5. Document reopen resets counter to 0 (Q2 Answer)
6. Session counter is total across all servers, not per-server (Q1 Answer)

**Acceptance Criteria**:
- Given: Test suite for document-scoped sessions
- When: Running tests
- Then: All session isolation scenarios pass
- And: Total session counting (across servers) verified (Q1)
- And: Document reopen reset behavior verified (Q2)
- And: Single-document reset verified (Q9)

---

### Feature-900-20: Smart Tool Result Caching

**Priority**: P1
**Story Points**: 5
**Description**: Don't re-execute tools if results already exist in document. Prompt user for re-execution with cached vs fresh options.

**Clarifications**:
- **Q3 Answer (Parameter Matching)**: Order-independent comparison ({a:1, b:2} equals {b:2, a:1})
  - Can be used with automatic sorting and document reformatting (like prettier behavior)
- **Q4 Answer (Cache Expiration)**: Results stay valid forever (until document edited/deleted)
  - User can re-trigger tools by editing the document and specific section
  - Document is like a chat with LLM history - re-execution left to user discretion
- **Q5 Answer (Manual Execution Behavior)**: When user passes with cursor over tool execution section
  - Show notification (like switching between render and edit modes)
- **Q11 Answer (Copy-Paste Auto-Execution)**: Pasted tool blocks wait for user to manually trigger
  - Relies on Q4 behavior (user controls re-execution)
- **Q12 Answer (Conflict with Existing Result)**: Show "Re-execute" prompt

**Files Affected**:
- `src/mcp/toolCallingCoordinator.ts`
- `src/codeBlockProcessor.ts`
- `src/mcp/toolResultCache.ts` (new)

#### UserStory-900-20-5: Detect Existing Tool Results

**Priority**: P1
**Story Points**: 5
**Description**: As a user, I don't want tools re-executed if results are already in my document unless I explicitly request it.

**Acceptance Criteria**:
- Given: Document contains tool result for `memory.store_memory({key: "test"})`
- When: LLM or user requests same tool with same parameters (order-independent - Q3)
- Then: Existing result is detected and offered as cached option
- And: User can choose to re-execute or use cached result
- And: Cached results stay valid until document is edited/deleted (Q4)
- And: Cursor hover over tool section shows notification (Q5)
- And: Pasted tool blocks wait for manual trigger, not auto-execute (Q11)

##### Task-900-20-5-1: Create tool result cache parser

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/toolResultCache.ts` (new)

**Changes Required**:
```typescript
interface ToolResultCache {
  serverId: string
  toolName: string
  parameters: Record<string, unknown>
  parameterHash: string
  content: unknown
  executedAt: number
  location: { line: number, ch: number }
}

export class DocumentToolCache {
  /**
   * Parse document for existing tool results
   * Parameters are compared using order-independent JSON hash
   */
  findExistingResult(
    editor: Editor,
    serverId: string,
    toolName: string,
    parameters: Record<string, unknown>
  ): ToolResultCache | null {
    const paramHash = this.hashParameters(parameters)
    const content = editor.getValue()

    // Parse markdown for tool execution blocks
    // Match by server, tool name, and parameter hash
    // Return cached result if found

    return null // or found result
  }

  private hashParameters(params: Record<string, unknown>): string {
    // Create order-independent hash (Q3 Answer)
    // Sort object keys to ensure {a:1, b:2} === {b:2, a:1}
    const sorted = JSON.stringify(params, Object.keys(params).sort())
    return createHash('sha256').update(sorted).digest('hex').substring(0, 16)
  }
}
```

**Acceptance Criteria**:
- Given: Document contains tool result
- When: Parsing for matching execution
- Then: Parameters are matched using order-independent comparison (Q3)
- And: Returns cached result with location information
- And: Cached results persist until document edited/deleted (Q4)

##### Task-900-20-5-2: Add re-execution confirmation UI

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
```typescript
async promptReExecution(
  toolName: string,
  cachedResult: ToolResultCache
): Promise<'re-execute' | 'use-cached' | 'cancel'> {
  return new Promise((resolve) => {
    const ageMinutes = Math.floor((Date.now() - cachedResult.executedAt) / 60000)
    const notice = new Notice('', 0)

    notice.noticeEl.createDiv({ cls: 'mcp-reexec-notice' }, (container) => {
      container.createEl('p', {
        text: `Tool "${toolName}" already executed ${ageMinutes}m ago.`
      })

      const actions = container.createDiv({ cls: 'mcp-reexec-actions' })

      actions.createEl('button', { text: 'Re-execute', cls: 'mod-warning' })
        .addEventListener('click', () => {
          notice.hide()
          resolve('re-execute')
        })

      actions.createEl('button', { text: 'Use Cached', cls: 'mod-cta' })
        .addEventListener('click', () => {
          notice.hide()
          resolve('use-cached')
        })

      actions.createEl('button', { text: 'Cancel' })
        .addEventListener('click', () => {
          notice.hide()
          resolve('cancel')
        })
    })
  })
}
```

**Acceptance Criteria**:
- Given: Tool result exists in document (Q12: Show "Re-execute" prompt)
- When: User manually triggers same tool (Q5: cursor hover shows notification)
- Then: Confirmation notice shown with three options
- And: Shows age of cached result (infinite until document edited - Q4)
- And: "Use Cached" is primary (highlighted) action
- And: Pasted tool blocks also trigger manual confirmation (Q11)

##### Task-900-20-5-3: Integrate cache detection in coordinator

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
```typescript
// Before executing tool:
const cache = new DocumentToolCache()
const existing = cache.findExistingResult(
  options.editor,
  serverId,
  toolCall.name,
  toolCall.arguments
)

if (existing && options.promptForCache) {
  const action = await this.promptReExecution(toolCall.name, existing)

  if (action === 'use-cached') {
    // Return cached result without execution
    return existing.content
  } else if (action === 'cancel') {
    throw new Error('Execution cancelled by user')
  }
  // If 're-execute', continue with normal execution
}
```

**Acceptance Criteria**:
- Given: Cached result exists in document
- When: Executing tool manually or via paste (Q11, Q12)
- Then: User is prompted to choose cached vs fresh (Q12: "Re-execute" prompt)
- And: LLM-triggered executions can use cached automatically (user controls via Q4)
- And: Manual executions always prompt user (Q5)
- And: Parameters matched order-independently (Q3)

---

### Feature-900-30: Collapsible Settings Sections

**Priority**: P2
**Story Points**: 5
**Description**: Make settings sections collapsible and remember user's expanded/collapsed state.

**Clarifications**:
- **Q6 Answer (Section State Persistence)**: Always track last state (expanded/collapsed) regardless of whether changes were made
  - Track state for every section toggle action
  - Remember preference across Obsidian restarts

**Files Affected**:
- `src/settingTab.ts`
- `src/settings.ts`

#### UserStory-900-30-5: Persistent Section State

**Priority**: P2
**Story Points**: 5
**Description**: As a user, I want settings sections to remember if I expanded or collapsed them across Obsidian sessions.

**Acceptance Criteria**:
- Given: Settings tab with collapsible sections
- When: User expands/collapses "MCP Servers" section
- Then: State is saved to settings immediately (Q6: always track last state)
- And: State persists across Obsidian restarts
- And: "MCP Servers" defaults to collapsed
- And: "System Message" section is also collapsible
- And: Every toggle action updates stored state (regardless of edits - Q6)

##### Task-900-30-5-1: Add UI state to settings schema

**Story Points**: 1
**Priority**: P2
**File**: `src/settings.ts`

**Changes Required**:
```typescript
export interface TarsSettings {
  // ... existing settings

  uiState?: {
    mcpServersExpanded?: boolean  // default: false
    systemMessageExpanded?: boolean  // default: false
  }
}

export const DEFAULT_SETTINGS: TarsSettings = {
  // ... existing defaults

  uiState: {
    mcpServersExpanded: false,
    systemMessageExpanded: false
  }
}
```

**Acceptance Criteria**:
- Given: Settings schema
- When: Adding UI state fields
- Then: Includes boolean flags for each collapsible section
- And: Defaults to collapsed (false)

##### Task-900-30-5-2: Implement collapsible MCP Servers section

**Story Points**: 2
**Priority**: P2
**File**: `src/settingTab.ts`

**Changes Required**:
```typescript
// Replace existing MCP section heading with collapsible details
const mcpSection = containerEl.createEl('details', {
  cls: 'setting-item setting-item-heading mcp-settings-section'
})

mcpSection.open = this.plugin.settings.uiState?.mcpServersExpanded ?? false

mcpSection.createEl('summary', {
  text: 'MCP Servers',
  cls: 'setting-item-name'
})

const mcpContent = mcpSection.createDiv({ cls: 'setting-item-description' })

// Move all existing MCP server settings into mcpContent

// Save state on toggle
mcpSection.addEventListener('toggle', () => {
  if (!this.plugin.settings.uiState) {
    this.plugin.settings.uiState = {}
  }
  this.plugin.settings.uiState.mcpServersExpanded = mcpSection.open
  this.plugin.saveSettings()
})
```

**Acceptance Criteria**:
- Given: Settings tab opened
- When: Viewing MCP Servers section
- Then: Section is collapsible using `<details>/<summary>`
- And: Default state is collapsed
- And: State persists when user toggles (always tracked - Q6)
- And: State remembered even if no changes made to section content

##### Task-900-30-5-3: Implement collapsible System Message section

**Story Points**: 1
**Priority**: P2
**File**: `src/settingTab.ts`

**Changes Required**:
```typescript
// Same pattern as MCP Servers section
const systemMsgSection = containerEl.createEl('details', {
  cls: 'setting-item setting-item-heading system-message-section'
})

systemMsgSection.open = this.plugin.settings.uiState?.systemMessageExpanded ?? false

systemMsgSection.createEl('summary', {
  text: 'System Message',
  cls: 'setting-item-name'
})

const systemMsgContent = systemMsgSection.createDiv({ cls: 'setting-item-description' })

// Move system message textarea into systemMsgContent

systemMsgSection.addEventListener('toggle', () => {
  if (!this.plugin.settings.uiState) {
    this.plugin.settings.uiState = {}
  }
  this.plugin.settings.uiState.systemMessageExpanded = systemMsgSection.open
  this.plugin.saveSettings()
})
```

**Acceptance Criteria**:
- Given: System Message section
- When: User toggles expand/collapse
- Then: State persists across sessions (always tracked - Q6)
- And: Defaults to collapsed
- And: State remembered regardless of content changes

##### Task-900-30-5-4: Add CSS styling for collapsible sections

**Story Points**: 1
**Priority**: P2
**File**: `styles.css`

**Changes Required**:
```css
.mcp-settings-section,
.system-message-section {
  border: none;
  margin: 0;
  padding: 0;
}

.mcp-settings-section summary,
.system-message-section summary {
  cursor: pointer;
  font-weight: 600;
  padding: 12px 0;
  user-select: none;
  list-style: none; /* Remove default arrow */
  display: flex;
  align-items: center;
}

.mcp-settings-section summary::before,
.system-message-section summary::before {
  content: 'â–¶';
  margin-right: 8px;
  transition: transform 0.2s ease;
}

.mcp-settings-section[open] summary::before,
.system-message-section[open] summary::before {
  transform: rotate(90deg);
}

.mcp-settings-section summary:hover,
.system-message-section summary:hover {
  color: var(--interactive-accent);
}

.mcp-settings-section[open] summary,
.system-message-section[open] summary {
  margin-bottom: 12px;
}
```

**Acceptance Criteria**:
- Given: Collapsible sections in settings
- When: Viewing and interacting
- Then: Custom arrow indicator (â–¶) rotates when expanded
- And: Hover state provides visual feedback
- And: Styling is consistent with Obsidian's design

---

### Feature-900-40: Enhanced Display Mode Toggle

**Priority**: P2
**Story Points**: 8
**Description**: Improve "Show as command" to support JSONâ†”Shell and URLâ†”Shell conversions intelligently. Recognize that JSONâ†’URL only works for mcp-remote compatible configs.

**Files Affected**:
- `src/settingTab.ts`
- `src/mcp/displayMode.ts` (new)
- `src/mcp/mcpUseAdapter.ts`

#### UserStory-900-40-5: Smart Conversion Modes

**Priority**: P2
**Story Points**: 8
**Description**: As a user, I need intelligent conversion between JSONâ†”Shell and URLâ†”Shell, understanding that JSONâ†’URL only works for mcp-remote configs.

**Acceptance Criteria**:
- Given: URL config
- When: Toggle button clicked
- Then: Shows "Show as command" (URL â†” mcp-remote shell command)
- And: Does NOT offer JSON conversion

- Given: JSON config (mcp-remote format)
- When: Toggle clicked
- Then: Can convert to URL or Shell command

- Given: JSON config (non-mcp-remote, e.g., stdio command)
- When: Toggle clicked
- Then: Can only convert to Shell command format (if applicable)
- And: JSONâ†’URL conversion not offered

##### Task-900-40-5-1: Create conversion capability detector

**Story Points**: 3
**Priority**: P2
**File**: `src/mcp/displayMode.ts` (new)

**Changes Required**:
```typescript
export interface ConversionCapability {
  canShowAsJson: boolean
  canShowAsUrl: boolean
  canShowAsShell: boolean
  currentFormat: 'json' | 'url' | 'shell'
  mcpRemoteCompatible: boolean
}

export function detectCapability(config: MCPServerConfig): ConversionCapability {
  // URL format (e.g., sse://example.com/mcp)
  if (isUrlConfig(config)) {
    return {
      canShowAsJson: false,  // URL cannot be shown as arbitrary JSON
      canShowAsUrl: true,
      canShowAsShell: true,  // Can show as: npx -y mcp-remote <url>
      currentFormat: 'url',
      mcpRemoteCompatible: true
    }
  }

  // JSON format
  if (isJsonConfig(config)) {
    const isMcpRemote = isMcpRemoteJsonFormat(config)

    return {
      canShowAsJson: true,
      canShowAsUrl: isMcpRemote,  // Only mcp-remote JSON can convert to URL
      canShowAsShell: true,  // Can show as shell command
      currentFormat: 'json',
      mcpRemoteCompatible: isMcpRemote
    }
  }

  // Shell command format
  return {
    canShowAsJson: false,  // Shell commands can't be shown as JSON
    canShowAsUrl: false,
    canShowAsShell: true,
    currentFormat: 'shell',
    mcpRemoteCompatible: false
  }
}

function isMcpRemoteJsonFormat(config: Record<string, unknown>): boolean {
  // Check if JSON structure matches mcp-remote generated format
  // mcp-remote generates: { command: "npx", args: ["-y", "mcp-remote", "<url>"] }
  if (config.command === 'npx' && Array.isArray(config.args)) {
    return config.args.includes('mcp-remote')
  }
  return false
}

function isUrlConfig(config: MCPServerConfig): boolean {
  return typeof config.url === 'string' && config.url.length > 0
}

function isJsonConfig(config: MCPServerConfig): boolean {
  return typeof config.command === 'string' || Array.isArray(config.args)
}
```

**Acceptance Criteria**:
- Given: Different config formats (URL, JSON-mcp-remote, JSON-stdio, shell)
- When: Detecting conversion capability
- Then: Correctly identifies which conversions are possible
- And: Flags mcp-remote compatibility accurately

##### Task-900-40-5-2: Update toggle UI with smart labels

**Story Points**: 3
**Priority**: P2
**File**: `src/settingTab.ts`

**Changes Required**:
```typescript
import { detectCapability, ConversionCapability } from './mcp/displayMode'

// For each server config in settings:
const capability = detectCapability(server)

// Only show toggle button if conversions are available
if (capability.canShowAsShell || capability.canShowAsUrl || capability.canShowAsJson) {
  const toggleButton = setting.addButton((btn) => {
    const label = getToggleLabel(capability, currentDisplayMode)
    btn.setButtonText(label)
    btn.setTooltip(getToggleTooltip(capability))
    btn.onClick(() => {
      // Cycle through available display modes
      currentDisplayMode = getNextDisplayMode(capability, currentDisplayMode)
      updateServerConfigDisplay(server, currentDisplayMode)
    })
  })
}

function getToggleLabel(cap: ConversionCapability, current: string): string {
  if (current === 'url' && cap.canShowAsShell) {
    return 'Show as command'
  } else if (current === 'shell' && cap.canShowAsUrl) {
    return 'Show as URL'
  } else if (current === 'json' && cap.canShowAsShell) {
    return 'Show as command'
  } else if (current === 'shell' && cap.canShowAsJson) {
    return 'Show as JSON'
  }
  return 'Toggle view'
}

function getToggleTooltip(cap: ConversionCapability): string {
  const modes = []
  if (cap.canShowAsUrl) modes.push('URL')
  if (cap.canShowAsJson) modes.push('JSON')
  if (cap.canShowAsShell) modes.push('Shell Command')

  return `Available formats: ${modes.join(' â†” ')}`
}
```

**Acceptance Criteria**:
- Given: Server config with conversion options
- When: Viewing toggle button
- Then: Label accurately describes next available conversion
- And: Tooltip shows all available format conversions
- And: Button hidden if no conversions possible

##### Task-900-40-5-3: Add conversion validation tests

**Story Points**: 2
**Priority**: P2
**File**: `tests/mcp/displayMode.test.ts` (new)

**Test Cases**:
1. URL config â†’ detects Shell conversion available
2. mcp-remote JSON â†’ detects URL and Shell conversions
3. stdio JSON â†’ detects only Shell conversion (no URL)
4. Shell command â†’ no JSON or URL conversion
5. Invalid conversion attempts rejected gracefully

**Acceptance Criteria**:
- Given: Test suite for display mode conversions
- When: Running tests
- Then: All conversion scenarios pass validation
- And: Invalid conversions properly rejected

---

### Feature-900-50: Enhanced Status Bar Modal

**Priority**: P1
**Story Points**: 3
**Description**: Show session counts in status modal, improve refresh behavior with full MCP server restart.

**Clarifications**:
- **Q7 Answer (Kill vs Stop)**: Graceful shutdown (send terminate signal, wait for cleanup)
  - Use graceful shutdown but with limited time, otherwise force kill
- **Q8 Answer (Delay Duration)**: 500ms (half second)
- **Q9 Answer (Session Reset Scope)**: Reset counter to 0 for current document only

**Files Affected**:
- `src/statusBarManager.ts`
- `src/modals/mcpStatusModal.ts`
- `src/mcp/managerMCPUse.ts`

#### UserStory-900-50-5: Session Count Display & Server Refresh

**Priority**: P1
**Story Points**: 3
**Description**: As a user, I need to see current session counts and have refresh properly restart MCP servers with clear visual feedback.

**Acceptance Criteria**:
- Given: Status modal open
- When: Viewing server details
- Then: Shows "Sessions: 3/25" total for current document (not per-server)
- And: Warning icon if limit reached

- Given: Refresh button clicked
- When: Restart sequence runs
- Then: UI shows status progression: "Stopping..." â†’ "Starting..." â†’ "Complete âœ“"
- And: Server icons update to reflect status changes
- And: Session counters reset to 0 for current document only (Q9)
- And: 500ms delay visible between stop and start (Q8)
- And: Servers shutdown gracefully with timeout, force kill if needed (Q7)

##### Task-900-50-5-1: Add session count display to status modal

**Story Points**: 1
**Priority**: P1
**File**: `src/statusBarManager.ts`

**Changes Required**:
```typescript
// In MCPStatusModal.renderServerDetails():
const currentDocPath = this.app.workspace.getActiveFile()?.path ?? ''

// Show TOTAL session count for document (not per-server - Q1)
const totalSessionCount = mcpExecutor.getTotalSessionCount(currentDocPath)
const sessionLimit = settings.mcpSessionLimit

// Display total sessions for this document
const sessionInfoEl = modalEl.createDiv({ cls: 'document-session-info' }, (div) => {
  const sessionText = div.createSpan({
    cls: 'session-count',
    text: `Document Sessions: ${totalSessionCount}/${sessionLimit} (total across all servers)`
  })

  if (totalSessionCount >= sessionLimit) {
    div.createSpan({
      cls: 'session-limit-warning',
      text: ' âš ï¸ Limit reached'
    })
    sessionText.addClass('session-limit-exceeded')
  } else if (totalSessionCount >= sessionLimit * 0.8) {
    // Warning at 80% threshold
    div.createSpan({
      cls: 'session-warning',
      text: ' âš¡ Near limit'
    })
  }
})
```

**Acceptance Criteria**:
- Given: Status modal displaying servers
- When: Current document has session history
- Then: Shows "Document Sessions: X/Y (total across all servers)" - not per-server (Q1)
- And: Warning icon (âš ï¸) when limit reached
- And: Alert icon (âš¡) when approaching limit (80%+)

##### Task-900-50-5-2: Implement graceful server restart with UI feedback

**Story Points**: 2
**Priority**: P1
**Files**: `src/statusBarManager.ts`, `src/modals/mcpStatusModal.ts`

**Changes Required**:
```typescript
// In MCPStatusModal:
async refreshWithRestart() {
  const statusEl = this.modalEl.createDiv({ cls: 'refresh-status' })
  const currentDocPath = this.app.workspace.getActiveFile()?.path

  try {
    // Phase 1: Stopping (Q7 Answer: Graceful shutdown with timeout)
    this.setRefreshStatus(statusEl, 'stopping', 'Stopping servers...')
    await mcpManager.stopAllServersGracefully({
      gracefulTimeout: 5000,  // Wait 5s for cleanup
      forceKillAfter: true     // Force kill if timeout exceeded
    })

    // Phase 2: Delay (Q8 Answer: 500ms)
    this.setRefreshStatus(statusEl, 'waiting', 'Waiting...')
    await sleep(500)

    // Phase 3: Starting
    this.setRefreshStatus(statusEl, 'starting', 'Starting servers...')
    await mcpManager.startAllServers()

    // Phase 4: Reset sessions (Q9 Answer: Current document only)
    if (currentDocPath) {
      mcpExecutor.resetSessionCount(currentDocPath)  // Only current doc
    }

    // Phase 5: Complete
    this.setRefreshStatus(statusEl, 'complete', 'Complete âœ“')
    await sleep(1000)

    // Refresh modal display
    await this.updateMCPStatus()

  } catch (error) {
    this.setRefreshStatus(statusEl, 'error', `Error: ${error.message}`)
  } finally {
    setTimeout(() => statusEl.remove(), 2000)
  }
}

private setRefreshStatus(
  el: HTMLElement,
  phase: 'stopping' | 'waiting' | 'starting' | 'complete' | 'error',
  message: string
) {
  el.empty()
  el.removeClass('stopping', 'waiting', 'starting', 'complete', 'error')
  el.addClass(phase)

  const icon = this.getPhaseIcon(phase)
  el.createSpan({ cls: 'refresh-icon', text: icon })
  el.createSpan({ cls: 'refresh-message', text: message })
}

private getPhaseIcon(phase: string): string {
  switch (phase) {
    case 'stopping': return 'â¸ï¸'
    case 'waiting': return 'â³'
    case 'starting': return 'â–¶ï¸'
    case 'complete': return 'âœ…'
    case 'error': return 'âŒ'
    default: return 'â€¢'
  }
}
```

**CSS Changes** (in `styles.css`):
```css
.refresh-status {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 16px;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  gap: 8px;
  z-index: 1000;
}

.refresh-status.stopping { border-left: 4px solid var(--color-orange); }
.refresh-status.waiting { border-left: 4px solid var(--color-yellow); }
.refresh-status.starting { border-left: 4px solid var(--color-blue); }
.refresh-status.complete { border-left: 4px solid var(--color-green); }
.refresh-status.error { border-left: 4px solid var(--color-red); }

.refresh-icon {
  font-size: 1.2em;
}

.refresh-message {
  font-weight: 500;
}
```

**Acceptance Criteria**:
- Given: Refresh button in status modal
- When: User clicks refresh
- Then: Toast notification shows progress through phases
- And: Status changes: Stopping â†’ Waiting â†’ Starting â†’ Complete
- And: Server status icons in main modal update in real-time
- And: 500ms delay is visible between stop and start (Q8)
- And: Session counter (total for document) shows 0/limit after complete (Q9)
- And: Servers shutdown gracefully with 5s timeout, force killed if needed (Q7)

---

### Feature-900-60: Auto-Generate Tool Parameters

**Priority**: P2
**Story Points**: 3
**Description**: Auto-generate parameter placeholders when tool selected from dropdown or browser modal.

**Clarifications**:
- **Q10 Answer (Parameter Placeholders)**: Empty strings/zeros: `""`, `0`, `false`, `[]`, `{}`
  - Arrays are tricky - can provide an object of the array as a commented line

**Files Affected**:
- `src/modals/toolBrowserModal.ts`
- `src/suggests/mcpToolSuggestHelpers.ts`

#### UserStory-900-60-5: Parameter Template Insertion

**Priority**: P2
**Story Points**: 3
**Description**: As a user, when I select a tool from dropdown or browser, I expect parameter templates to be auto-generated with type hints.

**Acceptance Criteria**:
- Given: Tool selected from browser modal or suggest
- When: Insert action triggered
- Then: Code block inserted with all parameters as typed placeholders (Q10)
- And: Cursor positioned at first required parameter value
- And: Placeholder format: `""` for strings, `0` for numbers, `false` for booleans, `[]` for arrays, `{}` for objects
- And: Arrays may include commented example object structure

##### Task-900-60-5-1: Verify existing template generation

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Review Existing Implementation**:
```typescript
// Already exists in toolBrowserModal.ts:210-235
// Verify it generates correct placeholders
```

**Enhancement Needed (Q10 Answer)**:
```typescript
private generateParameterPlaceholder(param: ParameterSchema): unknown {
  switch (param.type) {
    case 'string':
      return ""  // Empty string (Q10)
    case 'number':
    case 'integer':
      return 0   // Zero (Q10)
    case 'boolean':
      return false  // False (Q10)
    case 'array':
      // Arrays: provide empty array, optionally add commented example (Q10)
      // Example comment line could be added: # Example: [{"key": "value"}]
      return []
    case 'object':
      return {}  // Empty object (Q10)
    default:
      return null
  }
}
```

**Acceptance Criteria**:
- Given: Tool with typed parameters
- When: Generating template
- Then: Uses type-appropriate placeholders (Q10)
- And: String params use `""` (empty string)
- And: Numeric params use `0`
- And: Boolean params use `false`
- And: Arrays use `[]` with optional commented example
- And: Objects use `{}`

##### Task-900-60-5-2: Add cursor positioning after insert

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
```typescript
async insertToolTemplate(tool: ToolDefinition, serverId: string) {
  const template = this.generateTemplate(tool, serverId)
  const editor = this.getActiveEditor()

  const cursor = editor.getCursor()
  editor.replaceRange(template, cursor)

  // Position cursor at first parameter value
  const firstParamLine = cursor.line + 2 // Skip code fence and "tool:" line
  const firstParamValue = editor.getLine(firstParamLine)
  const colonPos = firstParamValue.indexOf(':')

  if (colonPos >= 0) {
    editor.setCursor({
      line: firstParamLine,
      ch: colonPos + 2 // After ": "
    })
  }

  this.close()
}
```

**Acceptance Criteria**:
- Given: Tool template inserted
- When: Modal closes
- Then: Cursor positioned at first parameter value
- And: User can immediately start typing

##### Task-900-60-5-3: Add test for parameter generation

**Story Points**: 1
**Priority**: P2
**File**: `tests/mcp/toolBrowserModal.test.ts`

**Test Cases**:
1. Tool with required string param â†’ generates `""` (empty string - Q10)
2. Tool with number param â†’ generates `0` (Q10)
3. Tool with optional params â†’ marked with `# optional` comment
4. Complex types (arrays, objects) â†’ correct placeholders `[]`, `{}` (Q10)
5. Arrays may include commented example structure (Q10)
6. Cursor positioned at first required param

**Acceptance Criteria**:
- Given: Test suite for tool template generation
- When: Running tests
- Then: All parameter type scenarios pass (Q10 placeholders)
- And: Cursor positioning verified
- And: Empty values for all types verified

---

### Feature-900-70: Unified Tool Result Formatting

**Priority**: P2
**Story Points**: 2
**Description**: LLM-executed and manually-executed tools should have identical formatting so users can copy/paste between documents.

**Files Affected**:
- `src/mcp/toolResultFormatter.ts` (new)
- `src/mcp/toolCallingCoordinator.ts`
- `src/codeBlockProcessor.ts`

#### UserStory-900-70-5: Consistent Tool Result Format

**Priority**: P2
**Story Points**: 2
**Description**: As a user, I need tool results formatted identically regardless of execution source so I can copy/paste them between documents.

**Acceptance Criteria**:
- Given: Tool result from LLM execution
- When: Formatting as markdown
- Then: Uses shared `formatToolResult()` function

- Given: Tool result from manual execution
- When: Formatting as markdown
- Then: Uses same `formatToolResult()` function

- And: Both formats are identical and copy-pastable
- And: Duration and Type have proper spacing: "Duration: 7ms, Type: json"

##### Task-900-70-5-1: Extract shared formatting function

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolResultFormatter.ts` (new)

**Changes Required**:
```typescript
export interface ToolExecutionResult {
  content: unknown
  executionDuration?: number
  isError?: boolean
  metadata?: Record<string, unknown>
}

export function formatToolResult(
  result: ToolExecutionResult,
  options?: {
    collapsible?: boolean
    showMetadata?: boolean
  }
): string {
  const duration = result.executionDuration ?? 0
  const contentType = Array.isArray(result.content)
    ? 'array'
    : typeof result.content

  // FIX: Add comma and space between Duration and Type
  const header = `**Result** (Duration: ${duration}ms, Type: ${contentType})`

  const contentStr = typeof result.content === 'string'
    ? result.content
    : JSON.stringify(result.content, null, 2)

  if (options?.collapsible !== false) {
    return `
${header}
<details>
<summary>View Result</summary>

\`\`\`json
${contentStr}
\`\`\`
</details>
`
  } else {
    return `
${header}
\`\`\`json
${contentStr}
\`\`\`
`
  }
}
```

**Acceptance Criteria**:
- Given: Tool execution result
- When: Formatting with `formatToolResult()`
- Then: Returns consistent markdown structure
- And: "Duration: Xms, Type: Y" has proper spacing (comma + space)
- And: Supports collapsible and inline modes

##### Task-900-70-5-2: Update coordinator and processor to use shared formatter

**Story Points**: 1
**Priority**: P2
**Files**: `src/mcp/toolCallingCoordinator.ts`, `src/codeBlockProcessor.ts`

**Changes Required**:
```typescript
// In toolCallingCoordinator.ts:
import { formatToolResult } from './toolResultFormatter'

// Replace inline formatting:
const resultMarkdown = formatToolResult(result, { collapsible: true })
options.editor?.replaceRange(resultMarkdown, cursor)

// In codeBlockProcessor.ts:
import { formatToolResult } from './toolResultFormatter'

// Replace inline formatting:
const resultMarkdown = formatToolResult(executionResult, { collapsible: true })
```

**Acceptance Criteria**:
- Given: Tool executed via LLM or manually
- When: Result inserted in document
- Then: Formatting is identical (same structure, spacing, collapsible details)
- And: "Duration: 7ms, Type: json" (not "Duration: 7msType: json")
- And: Results are interchangeable between documents

---

### Feature-900-80: Tool Registration Utility Section

**Priority**: P3
**Story Points**: 8
**Status**: Deferred to Epic-1000
**Description**: Track registered tools in document metadata section showing which tools are available to LLM during session.

**Rationale for Deferral**: This feature overlaps significantly with Epic-500 (Execution History). The utility section concept is valuable for advanced users but requires:
- Document metadata management
- Session tracking infrastructure
- Real-time updates as tools register/unregister

Recommend revisiting in Epic-1000 (Advanced Document Features) after execution history and caching are complete.

---

### Feature-900-90: MCP Server Commands

**Priority**: P3
**Story Points**: 5
**Status**: Deferred to Epic-1000
**Description**: Register Obsidian commands for each MCP server tool, allowing insertion via command palette.

**Rationale for Deferral**: Current implementation already provides Feature-400-40 (Templated Inserts) which includes command palette integration for tool browser modal. Per-tool commands would:
- Create potentially hundreds of commands (if many tools available)
- Clutter command palette
- Duplicate tool browser functionality

Recommend deferring to Epic-1000 for advanced users who want this level of granular command access. Could be opt-in via settings.

---

## Summary

### Phase Progress

**Phase 1: Stabilization (Epic-100)** - âœ… COMPLETE (18/18 SP)
- All critical bug fixes implemented and tested
- Build and tests passing (200 tests)

**Phase 2: Core Completeness (Epic-200)** - In Progress (12/32 SP - 38%)
- âœ… Feature-200-10: Auto-Disable Failed Servers (10 SP)
- âœ… Feature-200-40: SSE Support via mcp-remote (2 SP)
- â³ Feature-200-30: Tool Result Persistence (8 SP)
- â³ Feature-200-20: Claude Provider Integration (10 SP)

**Phase 7: Settings UI (Epic-700)** - Not Started (0/18 SP)
- Feature-700-10: Config Display Mode Toggle (5 SP)
- Feature-700-20: Refactor Settings UI (13 SP)

**Phase 8: Document-Scoped Sessions & Enhanced UX (Epic-900)** - Not Started (0/31 SP)
- Feature-900-10: Document-Scoped Session Management (8 SP)
- Feature-900-20: Smart Tool Result Caching (5 SP)
- Feature-900-30: Collapsible Settings Sections (5 SP)
- Feature-900-40: Enhanced Display Mode Toggle (8 SP)
- Feature-900-50: Enhanced Status Bar Modal (3 SP)
- Feature-900-60: Auto-Generate Tool Parameters (3 SP)
- Feature-900-70: Unified Tool Result Formatting (2 SP)

### Overall Progress
- **Completed**: 30/178 SP (17%)
- **Remaining**: 148 SP
- **Next Priority**: Epic-900 (Document-Scoped Sessions & Enhanced UX) - Critical P1 features for improved user workflows

---

**Document Version**: 1.2
**Last Updated**: 2025-10-06
**Estimated Total Effort**: Î£=178 story points (~8-10 weeks)
**Status**: In Progress (17% complete)
