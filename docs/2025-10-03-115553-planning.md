# MCP Integration Implementation Plan

**Created**: 2025-10-03
**Based on**: [2025-10-03-mcp-integration-review.md](2025-10-03-mcp-integration-review.md)
**Status**: Ready for Implementation
**Total Story Points**: 101

---

## Planning Principles & Instructions for LLMs

### Purpose
This document provides a structured breakdown of the MCP integration work identified in the review. It is designed to be consumed by LLMs (including future sessions) to understand the work scope, priorities, and implementation approach.

### Numbering System
- **Epic**: `Epic-{N00}` (e.g., Epic-100, Epic-200) - increments of 100
- **Feature**: `Feature-{Epic}-{N0}` (e.g., Feature-100-10, Feature-100-20) - increments of 10
- **UserStory**: `UserStory-{Feature}-{N}` (e.g., UserStory-100-10-5) - increments of 5
- **Task**: `Task-{UserStory}-{N}` (e.g., Task-100-10-5-1) - increments of 1

**Rationale**: Gaps between numbers allow inserting newly-discovered work items during implementation without renumbering. For example, if during Task-100-10-5-1 we discover a missing prerequisite, we can insert Task-100-10-5-0 without disrupting the sequence.

### Story Points Scale
- **1**: Simple 1-file change, < 10 lines, no new dependencies
- **2**: Simple logic change, 1-2 files, < 50 lines, existing patterns
- **3**: Moderate complexity, 2-3 files, requires new tests
- **5**: Complex logic, multiple files, new component/class
- **8**: Very complex, needs breakdown, architectural changes, cross-cutting concerns
- **13+**: MUST break down further - too large for single implementation

### Priority Levels
- **P0**: Production blocker - prevents deployment, breaks core functionality
- **P1**: Critical for release - core features, major bugs
- **P2**: Important for user experience - UX improvements, performance
- **P3**: Nice to have - advanced features, optimizations
- **P4**: Future consideration - deferred for later releases

### Acceptance Criteria Format
Each item should have clear, testable acceptance criteria using Given-When-Then format:

```
**Acceptance Criteria**:
- Given: [Initial state/context]
- When: [Action taken]
- Then: [Expected outcome/behavior]
```

### Implementation Instructions for LLMs

When implementing tasks from this plan:

1. **Start with Epic-100** (Production Blockers) - these unblock deployment
2. **Follow task order within each Epic** - dependencies are implicit in ordering
3. **Complete all tasks in a UserStory** before moving to next story
4. **Update this document** if you discover new tasks/stories during implementation
5. **Mark completed items** by changing status or adding completion notes
6. **Create tests** for all code changes (acceptance criteria define test cases)
7. **Document deviations** if implementation differs from plan

### Cross-References
- Original review: [2025-10-03-mcp-integration-review.md](2025-10-03-mcp-integration-review.md)
- Codebase root: `src/`
- Test root: `tests/`

---

## Epic-100: Critical Bug Fixes (Production Blockers)

**Priority**: P0
**Story Points**: 8
**Status**: Not Started
**Description**: Fix critical bugs that prevent MCP integration from functioning in production. These issues break core functionality and must be addressed before any new development.

**Dependencies**: None (highest priority)
**Risk**: High - without these fixes, MCP integration is non-functional

### Feature-100-10: Fix Server Initialization

**Priority**: P0
**Story Points**: 3
**Description**: Resolve ID/name mismatch between configuration adapter and session manager that prevents servers from starting.

**Files Affected**:
- `src/mcp/mcpUseAdapter.ts`
- `src/mcp/managerMCPUse.ts`
- `tests/mcp/mcpUseAdapter.test.ts`

#### UserStory-100-10-5: ID/Name Mismatch Resolution

**Priority**: P0
**Story Points**: 3
**Description**: As a developer, I need server IDs to be used consistently across the MCP client and session manager so that new servers can be successfully initialized and connected.

**Background**: Currently `toMCPUseConfig` registers servers under `config.name`, but `createSession` is called with `config.id`. This mismatch causes "Server not found in config" errors.

**Solution Approach**: Align on using `config.id` as the primary identifier throughout the lifecycle.

##### Task-100-10-5-1: Update mcpUseAdapter to use config.id

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/mcpUseAdapter.ts`
**Line**: ~41

**Changes Required**:
```typescript
// Before:
const serverKey = config.name

// After:
const serverKey = config.id || config.name
```

**Acceptance Criteria**:
- Given: A server configuration with both `id` and `name` fields
- When: Converting to MCP-use format via `toMCPUseServerConfig`
- Then: The map key uses `config.id` consistently

##### Task-100-10-5-2: Update managerMCPUse session creation

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/managerMCPUse.ts`
**Line**: ~68

**Changes Required**:
```typescript
// Ensure createSession and sessions.set use the same identifier
const session = await this.mcpClient.createSession(config.id, true)
this.sessions.set(config.id, session)
```

**Acceptance Criteria**:
- Given: A server ID passed to `createSession`
- When: Creating a new MCP session
- Then: The `sessions` map stores the session under the same `config.id` key

##### Task-100-10-5-3: Add unit tests for ID/name alignment

**Story Points**: 1
**Priority**: P0
**File**: `tests/mcp/mcpUseAdapter.test.ts` (create if needed)

**Test Cases**:
1. Server with matching ID and name
2. Server with different ID and name
3. Server with only name (no ID)

**Acceptance Criteria**:
- Given: A test server config with ID="mcp-server-123" and name="filesystem"
- When: Creating a session via the manager
- Then: Session is successfully created and retrievable by ID

### Feature-100-20: Enable Configuration Settings

**Priority**: P0
**Story Points**: 3
**Description**: Wire user-configured timeout and execution limits from settings UI to the executor, replacing hardcoded values.

**Files Affected**:
- `src/mcp/index.ts`
- `src/main.ts`
- `src/mcp/executor.ts`

#### UserStory-100-20-5: Wire Timeout Settings

**Priority**: P0
**Story Points**: 2
**Description**: As a user, I need my configured timeout settings to be respected so that I can control how long tools are allowed to execute.

**Background**: The executor hardcodes a 30-second timeout. Settings UI captures `mcpGlobalTimeout` but it's never used.

##### Task-100-20-5-1: Update createToolExecutor signature

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/index.ts`
**Line**: ~56-75

**Changes Required**:
```typescript
export function createToolExecutor(
  manager: MCPServerManager,
  options?: {
    timeout?: number
    concurrentLimit?: number
    sessionLimit?: number
  }
): ToolExecutor {
  const tracker = {
    concurrentLimit: options?.concurrentLimit ?? 3,
    sessionLimit: options?.sessionLimit ?? 25,
    timeout: options?.timeout ?? 30000,
    // ... other properties
  }
  return new ToolExecutor(manager, tracker)
}
```

**Acceptance Criteria**:
- Given: The `createToolExecutor` function signature
- When: Adding an optional `options` parameter
- Then: Accepts `timeout`, `concurrentLimit`, and `sessionLimit` fields

##### Task-100-20-5-2: Thread settings from main.ts

**Story Points**: 1
**Priority**: P0
**File**: `src/main.ts`
**Line**: ~47

**Changes Required**:
```typescript
this.mcpExecutor = createToolExecutor(this.mcpManager, {
  timeout: this.settings.mcpGlobalTimeout,
  concurrentLimit: this.settings.mcpConcurrentLimit,
  sessionLimit: this.settings.mcpSessionLimit
})
```

**Acceptance Criteria**:
- Given: Plugin settings loaded with user-configured timeout/limits
- When: Creating the tool executor in `main.ts`
- Then: Settings values are passed to the executor factory function

#### UserStory-100-20-10: Apply Execution Limits

**Priority**: P0
**Story Points**: 1
**Description**: As a user, I need my configured concurrent and session limits to be enforced so that resource usage is controlled.

##### Task-100-20-10-1: Update executor tracker initialization

**Story Points**: 1
**Priority**: P0
**File**: `src/mcp/executor.ts`
**Line**: ~79-96 (canExecute method)

**Changes Required**:
- Ensure `tracker.concurrentLimit` and `tracker.sessionLimit` are set from passed options
- Remove any hardcoded defaults in executor constructor

**Acceptance Criteria**:
- Given: User-configured limits passed to executor
- When: `canExecute()` checks execution limits
- Then: Uses configured values instead of hardcoded 3 and 25

### Feature-100-30: Activate Health Monitoring

**Priority**: P0
**Story Points**: 2
**Description**: Start the periodic health check timer that monitors MCP server status.

**Files Affected**:
- `src/main.ts`
- `src/mcp/index.ts` (for HEALTH_CHECK_INTERVAL constant)

#### UserStory-100-30-5: Start Health Check Timer

**Priority**: P0
**Story Points**: 2
**Description**: As a plugin user, I need automatic health monitoring of MCP servers so that I know when servers fail or disconnect.

**Background**: `HEALTH_CHECK_INTERVAL` constant exists but `performHealthCheck()` is never called automatically.

##### Task-100-30-5-1: Add setInterval in main.ts onload

**Story Points**: 1
**Priority**: P0
**File**: `src/main.ts`
**Line**: After line 47 (after creating mcpExecutor)

**Changes Required**:
```typescript
if (this.mcpManager) {
  this.healthCheckInterval = setInterval(async () => {
    await this.mcpManager.performHealthCheck()
    this.updateMCPStatus()
  }, HEALTH_CHECK_INTERVAL)
}
```

**Acceptance Criteria**:
- Given: MCP manager initialized successfully
- When: Plugin loads
- Then: Health check runs automatically every 30 seconds (HEALTH_CHECK_INTERVAL)

##### Task-100-30-5-2: Clear timer in onunload

**Story Points**: 1
**Priority**: P0
**File**: `src/main.ts`
**Line**: Before line 169 (in onunload method)

**Changes Required**:
```typescript
if (this.healthCheckInterval) {
  clearInterval(this.healthCheckInterval)
}
```

**Acceptance Criteria**:
- Given: Plugin unloading
- When: `onunload()` is called
- Then: Health check timer is properly cleared to prevent memory leaks

---

## Epic-200: Core Missing Features

**Priority**: P1
**Story Points**: 21
**Status**: Not Started
**Description**: Implement core features that are expected for a complete MCP integration but are currently missing.

**Dependencies**: Epic-100 (blockers must be fixed first)
**Risk**: Medium - affects user experience and feature completeness

### Feature-200-10: Auto-Disable Failed Servers

**Priority**: P1
**Story Points**: 5
**Description**: Automatically disable servers that fail repeatedly to prevent resource waste and improve UX.

**Files Affected**:
- `src/mcp/managerMCPUse.ts`
- `src/settingTab.ts` (for UI updates)

#### UserStory-200-10-5: Implement Failure Tracking

**Priority**: P1
**Story Points**: 3
**Description**: As a system, I need to track consecutive failures per server so that I can auto-disable chronically failing servers.

##### Task-200-10-5-1: Add failureCount to server config

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
- Add `failureCount?: number` to `MCPServerConfig` interface
- Initialize to 0 when server is created

**Acceptance Criteria**:
- Given: MCPServerConfig interface definition
- When: A server config is created
- Then: `failureCount` field is available and defaults to 0

##### Task-200-10-5-2: Increment on startServer failure

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`
**Line**: ~88-113 (startServer method)

**Changes Required**:
```typescript
async startServer(serverId: string): Promise<void> {
  const config = this.servers.get(serverId)
  try {
    const session = await this.mcpClient.createSession(serverId, true)
    this.sessions.set(serverId, session)
    config.failureCount = 0  // Reset on success
    this.emit('server-started', serverId)
  } catch (error) {
    config.failureCount = (config.failureCount || 0) + 1
    // ... existing error handling
  }
}
```

**Acceptance Criteria**:
- Given: A server start attempt that fails
- When: Error is caught in the catch block
- Then: `failureCount` is incremented by 1

##### Task-200-10-5-3: Reset on successful start

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`

**Acceptance Criteria**:
- Given: A server with `failureCount > 0`
- When: Server successfully starts
- Then: `failureCount` is reset to 0

#### UserStory-200-10-10: Auto-Disable Logic

**Priority**: P1
**Story Points**: 2
**Description**: As a user, I need servers that fail 3+ times consecutively to be auto-disabled so that they don't continue consuming resources.

##### Task-200-10-10-1: Check threshold and disable

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`
**Line**: ~88-113 (startServer catch block)

**Changes Required**:
```typescript
catch (error) {
  config.failureCount = (config.failureCount || 0) + 1
  if (config.failureCount >= 3) {
    config.enabled = false
    config.autoDisabled = true
    this.emit('server-auto-disabled', serverId)
  }
  throw error
}
```

**Acceptance Criteria**:
- Given: A server with 3 or more consecutive failures
- When: Another failure occurs
- Then: Server is marked as `enabled=false` and `autoDisabled=true`

##### Task-200-10-10-2: Emit server-auto-disabled event

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
- Emit event when auto-disable threshold is reached
- Update UI to show "Auto-disabled" status
- Add "Re-enable" button in settings

**Acceptance Criteria**:
- Given: A server that gets auto-disabled
- When: The `server-auto-disabled` event is emitted
- Then: UI is notified and updates the server status display

### Feature-200-20: Claude Provider Integration

**Priority**: P1
**Story Points**: 8
**Description**: Enable MCP tool calling for Claude/Anthropic provider, currently missing despite being advertised as supported.

**Files Affected**:
- `src/mcp/providerAdapters.ts` (new ClaudeProviderAdapter)
- `src/providers/claude.ts`
- `src/mcp/toolResponseParser.ts` (new ClaudeToolResponseParser)
- `tests/mcp/claudeProviderAdapter.test.ts` (new)

#### UserStory-200-20-5: Create Claude Provider Adapter

**Priority**: P1
**Story Points**: 5
**Description**: As a Claude user, I need an adapter that translates MCP tools into Claude's tool format so that I can use MCP tools with Claude models.

##### Task-200-20-5-1: Create ClaudeProviderAdapter class

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
export class ClaudeProviderAdapter implements ProviderAdapter<Anthropic.MessageStreamEvent> {
  async initialize(): Promise<void> { ... }
  async *sendRequest(messages: Message[]): AsyncGenerator<Anthropic.MessageStreamEvent> { ... }
  getParser(): ClaudeToolResponseParser { ... }
  findServerId(toolName: string): string | null { ... }
  formatToolResult(toolCallId: string, result: ToolExecutionResult): Message { ... }
}
```

**Acceptance Criteria**:
- Given: The `ProviderAdapter` interface
- When: Implementing `ClaudeProviderAdapter`
- Then: All interface methods are implemented and match Claude's API structure

##### Task-200-20-5-2: Implement buildTools for Claude format

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
- Use `buildClaudeTools` from `providerToolIntegration.ts`
- Claude format uses `input_schema` not `parameters`

**Acceptance Criteria**:
- Given: MCP tools with parameter schemas
- When: Converting for Claude
- Then: Tools use `input_schema` field (Claude-specific format)

##### Task-200-20-5-3: Implement formatToolResult for Claude

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
formatToolResult(toolCallId: string, result: ToolExecutionResult): Message {
  return {
    role: 'user',
    content: [{
      type: 'tool_result',
      tool_use_id: toolCallId,
      content: JSON.stringify(result.content)
    }]
  }
}
```

**Acceptance Criteria**:
- Given: A tool execution result
- When: Formatting for Claude
- Then: Returns proper `tool_result` message in Claude's format

##### Task-200-20-5-4: Add ClaudeToolResponseParser

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolResponseParser.ts`

**Changes Required**:
- Parse `Anthropic.MessageStreamEvent` for `tool_use` content blocks
- Accumulate streaming tool use blocks
- Extract tool ID, name, and input

**Acceptance Criteria**:
- Given: Anthropic streaming events with tool use
- When: Parsing chunks
- Then: Correctly extracts `tool_use` blocks with ID, name, and input

#### UserStory-200-20-10: Integrate into Claude Provider

**Priority**: P1
**Story Points**: 3
**Description**: As a developer, I need the Claude provider to use the new adapter so that tool calling is available in Claude conversations.

##### Task-200-20-10-1: Update sendRequestFunc signature

**Story Points**: 1
**Priority**: P1
**File**: `src/providers/claude.ts`

**Changes Required**:
- Add optional `mcpManager` and `mcpExecutor` parameters to `sendRequestFunc`
- Follow the pattern used in `src/providers/ollama.ts:11-52`

**Acceptance Criteria**:
- Given: The `sendRequestFunc` function in claude.ts
- When: Adding MCP dependencies
- Then: Accepts optional `mcpManager` and `mcpExecutor` parameters

##### Task-200-20-10-2: Route through ToolCallingCoordinator

**Story Points**: 1
**Priority**: P1
**File**: `src/providers/claude.ts`

**Changes Required**:
```typescript
if (mcpManager && mcpExecutor) {
  const { ToolCallingCoordinator, ClaudeProviderAdapter } = await import('../mcp/index.js')

  const adapter = new ClaudeProviderAdapter({
    mcpManager, mcpExecutor, anthropicClient, controller, model
  })

  await adapter.initialize()
  const coordinator = new ToolCallingCoordinator()

  yield* coordinator.generateWithTools(
    formattedMessages, adapter, mcpExecutor, { documentPath }
  )
}
```

**Acceptance Criteria**:
- Given: MCP manager and executor available
- When: Streaming Claude response
- Then: Uses `ToolCallingCoordinator` for autonomous tool execution

##### Task-200-20-10-3: Add unit tests for Claude adapter

**Story Points**: 1
**Priority**: P1
**File**: `tests/mcp/claudeProviderAdapter.test.ts` (new)

**Test Cases**:
1. Initialize adapter and build tools
2. Parse tool_use from streaming events
3. Format tool results correctly
4. Handle multi-turn conversation with tools

**Acceptance Criteria**:
- Given: Mock Anthropic streaming events
- When: Running adapter tests
- Then: All tool calling scenarios pass (init, parse, format, multi-turn)

### Feature-200-30: Tool Result Persistence

**Priority**: P1
**Story Points**: 8
**Description**: Write tool calls and results to markdown documents so users can see what tools were executed and audit LLM behavior.

**Files Affected**:
- `src/mcp/toolCallingCoordinator.ts`
- `src/editor.ts`

#### UserStory-200-30-5: Persist Tool Calls in Documents

**Priority**: P1
**Story Points**: 5
**Description**: As a user, I need tool invocations written to my markdown document so that I have a record of what tools were called during AI generation.

##### Task-200-30-5-1: Modify ToolCallingCoordinator to accept editor

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
```typescript
async *generateWithTools(
  messages: Message[],
  adapter: ProviderAdapter,
  executor: ToolExecutor,
  options: GenerateOptions & { editor?: Editor }
): AsyncGenerator<string>
```

**Acceptance Criteria**:
- Given: The `generateWithTools` method signature
- When: Adding optional `editor` to options
- Then: Editor is available for inserting markdown during generation

##### Task-200-30-5-2: Insert tool call markdown format

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`
**Line**: ~116-156 (before executing tool)

**Changes Required**:
```typescript
if (options.editor) {
  const toolCallMarkdown = `\n\n[🔧 Tool: ${toolCall.name}](mcp://${serverId}/${toolCall.name})\n\`\`\`json\n${JSON.stringify(toolCall.arguments, null, 2)}\n\`\`\`\n`
  options.editor.replaceRange(toolCallMarkdown, options.editor.getCursor())
}
```

**Acceptance Criteria**:
- Given: A tool about to be executed
- When: Inserting tool call into document
- Then: Formatted markdown shows tool name and parameters in code block

##### Task-200-30-5-3: Insert tool result markdown

**Story Points**: 2
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`
**Line**: ~116-156 (after executing tool)

**Changes Required**:
```typescript
if (options.editor) {
  const resultMarkdown = `\n**Result** (${result.executionDuration}ms):\n<details>\n<summary>View Result</summary>\n\n\`\`\`json\n${JSON.stringify(result.content, null, 2)}\n\`\`\`\n</details>\n`
  options.editor.replaceRange(resultMarkdown, options.editor.getCursor())
}
```

**Acceptance Criteria**:
- Given: A tool execution completed
- When: Inserting result into document
- Then: Shows duration, content type, and collapsible result

#### UserStory-200-30-10: Format Tool Results

**Priority**: P1
**Story Points**: 3
**Description**: As a user, I need tool results formatted clearly so that I can easily understand what data the tool returned.

##### Task-200-30-10-1: Design result markdown template

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Template Design**:
```markdown
[🔧 Tool: tool_name](mcp://server-id/tool_name)
```json
{ parameters }
```

**Result** (123ms):
<details>
<summary>View Result</summary>

```json
{ result content }
```
</details>
```

**Acceptance Criteria**:
- Given: A tool execution result
- When: Formatting as markdown
- Then: Uses `<details>/<summary>` for collapsible sections

##### Task-200-30-10-2: Handle different content types

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
- JSON content: ````json` syntax
- Text content: ````text` or plain text
- Markdown content: render directly

**Acceptance Criteria**:
- Given: Tool results with JSON, text, or markdown content
- When: Rendering in document
- Then: Appropriate syntax highlighting applied

##### Task-200-30-10-3: Add metadata display

**Story Points**: 1
**Priority**: P1
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
- Show execution duration
- Show content type
- Show token usage if available

**Acceptance Criteria**:
- Given: Tool result with metadata
- When: Displaying in document
- Then: Shows duration (ms), content type, and tokens used

---

## Epic-300: Performance & Resource Management

**Priority**: P2
**Story Points**: 13
**Status**: Not Started
**Description**: Optimize performance and prevent resource leaks in the MCP integration.

**Dependencies**: Epic-100, Epic-200
**Risk**: Low-Medium - affects performance but not core functionality

### Feature-300-10: Tool Discovery Caching

**Priority**: P2
**Story Points**: 5
**Description**: Cache tool server mappings to reduce redundant async calls on every request.

**Files Affected**:
- `src/mcp/providerAdapters.ts`
- `src/mcp/managerMCPUse.ts`

#### UserStory-300-10-5: Cache Tool Server Mappings

**Priority**: P2
**Story Points**: 3
**Description**: As a system, I need to cache `buildToolServerMapping` results so that I don't make redundant tool listing calls on every request.

##### Task-300-10-5-1: Add cache Map to provider adapters

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
```typescript
export class OpenAIProviderAdapter implements ProviderAdapter<OpenAI.ChatCompletionChunk> {
  private toolMapping: Map<string, string> = new Map()

  async initialize(): Promise<void> {
    this.toolMapping = await buildToolServerMapping(this.mcpManager)
  }

  async buildTools() {
    // Use cached this.toolMapping instead of calling buildToolServerMapping again
  }
}
```

**Acceptance Criteria**:
- Given: A `ProviderAdapter` class
- When: Adding `toolMapping` cache
- Then: Cached on `initialize()`, reused in `buildTools()`

##### Task-300-10-5-2: Invalidate cache on server changes

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
- Listen for `server-started`, `server-stopped` events
- Clear cache when configuration changes

**Acceptance Criteria**:
- Given: A server is enabled or disabled
- When: Configuration changes
- Then: Tool mapping cache is cleared and rebuilt on next request

##### Task-300-10-5-3: Add cache metrics

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Changes Required**:
- Track cache hits/misses
- Log to console in development mode

**Acceptance Criteria**:
- Given: Tool mapping cache in use
- When: Tracking usage
- Then: Logs cache hit/miss ratio for debugging

#### UserStory-300-10-10: Optimize Tool Listing

**Priority**: P2
**Story Points**: 2
**Description**: As a system, I need to reduce redundant async calls during tool discovery so that performance improves.

##### Task-300-10-10-1: Batch tool listing requests

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Acceptance Criteria**:
- Given: Multiple provider adapters initializing
- When: Calling `buildToolServerMapping`
- Then: Single shared call instead of multiple parallel calls

##### Task-300-10-10-2: Add lazy initialization option

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/providerAdapters.ts`

**Acceptance Criteria**:
- Given: A provider adapter created
- When: No immediate tool usage needed
- Then: Defer tool discovery until first request

### Feature-300-20: Memory Leak Prevention

**Priority**: P2
**Story Points**: 3
**Description**: Ensure proper cleanup of active executions on all error paths to prevent memory leaks.

**Files Affected**:
- `src/mcp/executor.ts`
- `tests/mcp/executor.test.ts`

#### UserStory-300-20-5: Fix Execution Cleanup

**Priority**: P2
**Story Points**: 3
**Description**: As a system, I need to ensure `activeExecutions` is cleaned up on ALL error paths so that memory doesn't leak during errors.

##### Task-300-20-5-1: Audit error paths in executor

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/executor.ts`

**Action Items**:
- Review all methods in `ToolExecutor`
- Identify all error paths
- Document paths that might skip cleanup

**Acceptance Criteria**:
- Given: All executor methods
- When: Reviewing error handling
- Then: Documented all paths that might skip `activeExecutions.delete()`

##### Task-300-20-5-2: Add cleanup to error handlers

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Ensure `finally` blocks handle cleanup
- Add try-catch around cleanup code itself
- Use `executionRecord.requestId` for guaranteed cleanup

**Acceptance Criteria**:
- Given: Error occurring in `executeTool`
- When: Exception is thrown
- Then: `activeExecutions.delete()` is still called in finally block

##### Task-300-20-5-3: Add memory leak detection tests

**Story Points**: 1
**Priority**: P2
**File**: `tests/mcp/executor.test.ts`

**Test Cases**:
1. Force 100 failed executions
2. Check `activeExecutions.size` remains 0
3. Verify no unbounded growth

**Acceptance Criteria**:
- Given: Test with 100+ forced errors
- When: Running executions
- Then: `activeExecutions` size stays bounded (doesn't grow indefinitely)

### Feature-300-30: Error Recovery Mechanism

**Priority**: P2
**Story Points**: 5
**Description**: Add exponential backoff retry for transient failures so servers can recover automatically.

**Files Affected**:
- `src/mcp/managerMCPUse.ts`
- `src/settingTab.ts` (for retry config UI)

#### UserStory-300-30-5: Exponential Backoff Retry

**Priority**: P2
**Story Points**: 5
**Description**: As a user, I need transient server failures to be retried automatically with exponential backoff so that temporary network issues don't permanently disable servers.

##### Task-300-30-5-1: Add RetryPolicy configuration

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
```typescript
interface RetryPolicy {
  maxRetries: number        // default: 3
  initialDelay: number      // default: 1000ms
  maxDelay: number          // default: 30000ms
  backoffMultiplier: number // default: 2
}
```

**Acceptance Criteria**:
- Given: Server configuration
- When: Adding retry settings
- Then: `maxRetries`, `initialDelay`, `maxDelay` are configurable

##### Task-300-30-5-2: Implement exponential backoff

**Story Points**: 2
**Priority**: P2
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
```typescript
async startServerWithRetry(serverId: string): Promise<void> {
  let delay = this.retryPolicy.initialDelay

  for (let attempt = 0; attempt <= this.retryPolicy.maxRetries; attempt++) {
    try {
      await this.startServer(serverId)
      return // Success
    } catch (error) {
      if (attempt < this.retryPolicy.maxRetries && this.isTransientError(error)) {
        await sleep(delay)
        delay = Math.min(delay * this.retryPolicy.backoffMultiplier, this.retryPolicy.maxDelay)
      } else {
        throw error
      }
    }
  }
}
```

**Acceptance Criteria**:
- Given: A failed server start
- When: Retrying with backoff
- Then: Delay increases exponentially (1s, 2s, 4s, 8s) up to max

##### Task-300-30-5-3: Classify transient vs permanent errors

**Story Points**: 1
**Priority**: P2
**File**: `src/mcp/managerMCPUse.ts`

**Changes Required**:
```typescript
isTransientError(error: Error): boolean {
  // Network errors → retry
  if (error.message.includes('ECONNREFUSED')) return true
  if (error.message.includes('ETIMEDOUT')) return true

  // Config errors → don't retry
  if (error.message.includes('not found in config')) return false
  if (error.message.includes('invalid command')) return false

  return false // Default: don't retry unknown errors
}
```

**Acceptance Criteria**:
- Given: A server startup error
- When: Analyzing error type
- Then: Network errors are retried, configuration errors are not

##### Task-300-30-5-4: Add retry status to UI

**Story Points**: 1
**Priority**: P2
**File**: `src/settingTab.ts`

**Changes Required**:
- Show retry countdown in server status
- Display "Retrying in 4s..." during backoff
- Show attempt count "Attempt 2/3"

**Acceptance Criteria**:
- Given: A server in retry backoff
- When: Viewing status in settings UI
- Then: Shows "Retrying in 4s... (Attempt 2/3)"

---

## Epic-400: User Experience Enhancements

**Priority**: P2
**Story Points**: 21
**Status**: Not Started
**Description**: Improve user experience for discovering and using MCP tools.

**Dependencies**: Epic-100, Epic-200
**Risk**: Low - purely UX improvements, no breaking changes

### Feature-400-10: Tool Browser Modal

**Priority**: P2
**Story Points**: 8
**Description**: Create a modal UI to browse all available MCP tools across servers, with search and insert capabilities.

**Files Affected**:
- `src/modals/toolBrowserModal.ts` (new)
- `src/main.ts` (register command)

#### UserStory-400-10-5: Create Tool Browser UI

**Priority**: P2
**Story Points**: 5
**Description**: As a user, I need a way to browse all available MCP tools so that I can discover what tools are available and how to use them.

##### Task-400-10-5-1: Create ToolBrowserModal class

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts` (new)

**Changes Required**:
```typescript
export class ToolBrowserModal extends Modal {
  constructor(app: App, mcpManager: MCPServerManager) {
    super(app)
    this.mcpManager = mcpManager
  }

  onOpen() {
    this.contentEl.createEl('h2', { text: 'Browse MCP Tools' })
    // Server selector, tool list, search
  }
}
```

**Acceptance Criteria**:
- Given: Modal class extending `Obsidian.Modal`
- When: Opening the modal
- Then: Shows a list of all servers and their tools

##### Task-400-10-5-2: Add server filter dropdown

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
- Add dropdown with all server names
- "All Servers" option to show everything
- Filter tool list based on selection

**Acceptance Criteria**:
- Given: Multiple servers available
- When: Selecting a server in dropdown
- Then: Tool list filters to show only that server's tools

##### Task-400-10-5-3: Render tool cards

**Story Points**: 2
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Card Layout**:
```html
<div class="tool-card">
  <h3>tool_name</h3>
  <p class="tool-description">Description...</p>
  <details>
    <summary>Parameters</summary>
    <ul>
      <li><strong>param1</strong> (string, required): Description</li>
    </ul>
  </details>
  <button>Insert Code Block</button>
</div>
```

**Acceptance Criteria**:
- Given: A tool from an MCP server
- When: Rendering in the modal
- Then: Shows name, description, and expandable parameter schema

##### Task-400-10-5-4: Add search/filter functionality

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
- Add search input at top
- Filter tools by name/description in real-time
- Highlight matching text

**Acceptance Criteria**:
- Given: Search input in modal
- When: Typing a tool name or keyword
- Then: Tool list filters in real-time to show matches

#### UserStory-400-10-10: Tool Insert Actions

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need to insert tool code blocks from the browser so that I don't have to manually type the syntax.

##### Task-400-10-10-1: Add "Insert Code Block" button

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Changes Required**:
- Add button to each tool card
- On click, close modal and insert code block at cursor

**Acceptance Criteria**:
- Given: A tool card in the browser
- When: Clicking "Insert Code Block"
- Then: Code block template is inserted at cursor position

##### Task-400-10-10-2: Generate parameter templates

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/toolBrowserModal.ts`

**Template Format**:
````markdown
```server-name
tool: tool_name
param1:
param2:
```
````

**Acceptance Criteria**:
- Given: A tool with a parameter schema
- When: Generating the template
- Then: Includes all parameters with placeholder values or examples

##### Task-400-10-10-3: Add command palette integration

**Story Points**: 1
**Priority**: P2
**File**: `src/main.ts`

**Changes Required**:
```typescript
this.addCommand({
  id: 'browse-mcp-tools',
  name: 'Browse MCP Tools',
  callback: () => {
    new ToolBrowserModal(this.app, this.mcpManager).open()
  }
})
```

**Acceptance Criteria**:
- Given: Command palette open
- When: Typing "Browse MCP Tools"
- Then: Command appears and opens the tool browser modal

### Feature-400-20: Tool Auto-Completion

**Priority**: P2
**Story Points**: 8
**Description**: Add auto-completion for tool names and parameters in code blocks.

**Files Affected**:
- `src/suggests/mcpToolSuggest.ts` (new)
- `src/suggests/mcpParameterSuggest.ts` (new)
- `src/main.ts` (register suggests)

#### UserStory-400-20-5: Tool Name Auto-Complete

**Priority**: P2
**Story Points**: 5
**Description**: As a user, I need auto-completion when typing tool names so that I don't have to remember exact tool names.

##### Task-400-20-5-1: Create MCPToolSuggest class

**Story Points**: 2
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts` (new)

**Changes Required**:
```typescript
export class MCPToolSuggest extends EditorSuggest<ToolSuggestion> {
  onTrigger(cursor: EditorPosition, editor: Editor): EditorSuggestTriggerInfo | null {
    const line = editor.getLine(cursor.line)
    if (line.startsWith('tool:')) {
      const partial = line.substring(5).trim()
      return { start: { line: cursor.line, ch: 5 }, end: cursor, query: partial }
    }
    return null
  }

  async getSuggestions(context: EditorSuggestContext): Promise<ToolSuggestion[]> {
    // Return matching tools
  }
}
```

**Acceptance Criteria**:
- Given: An `EditorSuggest` subclass
- When: Typing in a code block after `tool:`
- Then: Suggests available tool names for that server

##### Task-400-20-5-2: Detect code block context

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts`

**Changes Required**:
- Parse code fence to get server name
- Only suggest tools from that server
- Handle invalid/unknown server names gracefully

**Acceptance Criteria**:
- Given: Cursor inside a code block with fence ```server-name```
- When: Checking context
- Then: Identifies server name and filters suggestions accordingly

##### Task-400-20-5-3: Fetch tools for server

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts`

**Changes Required**:
- Use `mcpManager.getToolsForServer(serverName)`
- Cache tools per server
- Handle server not running errors

**Acceptance Criteria**:
- Given: A server name identified from code fence
- When: Getting suggestions
- Then: Returns only tools from that server

##### Task-400-20-5-4: Render suggestions with descriptions

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpToolSuggest.ts`

**Suggestion Render**:
```
tool_name
Brief description of what this tool does
```

**Acceptance Criteria**:
- Given: Tool suggestions to display
- When: Rendering in suggestion list
- Then: Shows tool name prominently and description below

#### UserStory-400-20-10: Parameter Auto-Complete

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need auto-completion for parameter names so that I know what parameters each tool expects.

##### Task-400-20-10-1: Create MCPParameterSuggest class

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpParameterSuggest.ts` (new)

**Changes Required**:
```typescript
export class MCPParameterSuggest extends EditorSuggest<ParameterSuggestion> {
  onTrigger(cursor: EditorPosition, editor: Editor) {
    // Detect parameter line
    // Get tool name from earlier in block
    // Suggest parameters
  }
}
```

**Acceptance Criteria**:
- Given: An `EditorSuggest` subclass for parameters
- When: Typing a parameter line in code block
- Then: Suggests parameter names for the current tool

##### Task-400-20-10-2: Parse parameter schema

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpParameterSuggest.ts`

**Changes Required**:
- Extract parameter info from tool schema
- Get name, type, required status, description
- Show examples if available

**Acceptance Criteria**:
- Given: A tool schema with parameters
- When: Extracting parameter info
- Then: Returns name, type, required flag, and description

##### Task-400-20-10-3: Show parameter metadata

**Story Points**: 1
**Priority**: P2
**File**: `src/suggests/mcpParameterSuggest.ts`

**Suggestion Render**:
```
param_name (string) *
Description of parameter
```

**Acceptance Criteria**:
- Given: Parameter suggestions
- When: Rendering
- Then: Shows type in parentheses, `*` for required params

### Feature-400-30: Enhanced Status Display

**Priority**: P2
**Story Points**: 5
**Description**: Improve status bar and modal with real-time updates and detailed metrics.

**Files Affected**:
- `src/statusBarManager.ts`
- `src/modals/mcpStatusModal.ts`

#### UserStory-400-30-5: Real-Time Status Updates

**Priority**: P2
**Story Points**: 3
**Description**: As a user, I need real-time status updates so that I can see server state changes immediately.

##### Task-400-30-5-1: Listen to manager events

**Story Points**: 1
**Priority**: P2
**File**: `src/statusBarManager.ts`

**Changes Required**:
```typescript
mcpManager.on('server-started', () => this.updateMCPStatus())
mcpManager.on('server-stopped', () => this.updateMCPStatus())
mcpManager.on('server-failed', () => this.updateMCPStatus())
```

**Acceptance Criteria**:
- Given: A server status change event
- When: Event is emitted
- Then: Status bar updates immediately without waiting for next health check

##### Task-400-30-5-2: Add execution count to status

**Story Points**: 1
**Priority**: P2
**File**: `src/statusBarManager.ts`

**Display Format**:
```
Tars | MCP: 2/3 (15 tools, 3 active)
```

**Acceptance Criteria**:
- Given: Tools currently executing
- When: Viewing status bar
- Then: Shows active execution count: "MCP: 2/3 (15 tools, 3 active)"

##### Task-400-30-5-3: Add error indicators

**Story Points**: 1
**Priority**: P2
**File**: `src/statusBarManager.ts`

**Changes Required**:
- Show ⚠️ icon if any server has errors
- Include error count in tooltip
- Change status bar color on critical errors

**Acceptance Criteria**:
- Given: A server in error state
- When: Viewing status bar
- Then: Shows warning icon and error count in tooltip

#### UserStory-400-30-10: Enhanced Status Modal

**Priority**: P2
**Story Points**: 2
**Description**: As a user, I need detailed metrics in the status modal so that I can monitor MCP performance.

##### Task-400-30-10-1: Add execution statistics

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/mcpStatusModal.ts`

**Metrics to Show**:
- Total executions
- Average execution duration
- Success rate
- Error rate

**Acceptance Criteria**:
- Given: Status modal open
- When: Viewing server details
- Then: Shows total executions, avg duration, success/error rates

##### Task-400-30-10-2: Add refresh button

**Story Points**: 1
**Priority**: P2
**File**: `src/modals/mcpStatusModal.ts`

**Changes Required**:
- Add "Refresh" button to modal
- Re-query server health on click
- Update display without closing modal

**Acceptance Criteria**:
- Given: Status modal open
- When: Clicking refresh button
- Then: Re-queries server health and updates display in place

---

## Epic-500: Advanced Features

**Priority**: P3
**Story Points**: 21
**Status**: Not Started
**Description**: Advanced features that enhance power-user workflows and efficiency.

**Dependencies**: Epic-100, Epic-200, Epic-300, Epic-400
**Risk**: Low - optional enhancements, can be deferred

### Feature-500-10: Parallel Tool Execution

**Priority**: P3
**Story Points**: 8
**Description**: Allow multiple tools to execute concurrently when LLM requests multiple tools.

**Files Affected**:
- `src/mcp/toolCallingCoordinator.ts`
- `src/mcp/executor.ts`
- `src/settingTab.ts`

#### UserStory-500-10-5: Implement Parallel Execution

**Priority**: P3
**Story Points**: 5
**Description**: As a power user, I need tools to execute in parallel so that multi-tool workflows complete faster.

##### Task-500-10-5-1: Add parallel execution mode to coordinator

**Story Points**: 2
**Priority**: P3
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
```typescript
if (options.parallelExecution) {
  const toolPromises = toolCalls.map(async (toolCall) => {
    const serverId = adapter.findServerId(toolCall.name)
    return executor.executeTool({ serverId, toolName: toolCall.name, ... })
  })
  const results = await Promise.all(toolPromises)
} else {
  // Existing sequential execution
}
```

**Acceptance Criteria**:
- Given: Multiple tool calls from LLM
- When: `parallelExecution` option is enabled
- Then: Uses `Promise.all()` instead of sequential `await`

##### Task-500-10-5-2: Add execution synchronization

**Story Points**: 2
**Priority**: P3
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Use mutex/semaphore for `activeExecutions` Set operations
- Ensure concurrent limit is enforced across parallel executions
- Thread-safe cleanup

**Acceptance Criteria**:
- Given: Parallel tool execution
- When: Tracking active executions
- Then: Properly synchronizes updates to `activeExecutions` Set

##### Task-500-10-5-3: Handle partial failures

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/toolCallingCoordinator.ts`

**Changes Required**:
- Catch errors per-tool in parallel execution
- Return successful results even if some fail
- Log failures without stopping other tools

**Acceptance Criteria**:
- Given: 3 tools executing in parallel
- When: 1 fails and 2 succeed
- Then: Successful results are returned, error is logged but doesn't block

#### UserStory-500-10-10: Configuration & Safety

**Priority**: P3
**Story Points**: 3
**Description**: As an administrator, I need to configure parallel execution limits so that resource usage is controlled.

##### Task-500-10-10-1: Add parallelExecution setting

**Story Points**: 1
**Priority**: P3
**File**: `src/settingTab.ts`

**UI Element**:
```typescript
new Setting(containerEl)
  .setName('Enable parallel tool execution')
  .setDesc('Allow multiple tools to execute concurrently (experimental)')
  .addToggle(toggle => toggle
    .setValue(settings.parallelExecution ?? false)
    .onChange(async (value) => { ... })
  )
```

**Acceptance Criteria**:
- Given: Settings UI
- When: Adding parallel execution toggle
- Then: Defaults to `false` for safety

##### Task-500-10-10-2: Add max parallel limit

**Story Points**: 1
**Priority**: P3
**File**: `src/settingTab.ts`

**Changes Required**:
- Add numeric input for max parallel executions
- Enforce limit in coordinator
- Default to concurrentLimit setting

**Acceptance Criteria**:
- Given: Parallel execution enabled
- When: LLM requests 10 tools
- Then: Only executes `concurrentLimit` at once, queues the rest

##### Task-500-10-10-3: Add parallel execution tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/toolCallingCoordinator.test.ts`

**Test Cases**:
1. Execute 3 tools in parallel
2. Verify all complete correctly
3. Test partial failure handling
4. Verify concurrent limit enforcement

**Acceptance Criteria**:
- Given: Test with multiple tool calls
- When: Running in parallel mode
- Then: All tools execute, results are correct, errors handled

### Feature-500-20: Tool Result Caching

**Priority**: P3
**Story Points**: 8
**Description**: Cache tool execution results to avoid redundant calls with same parameters.

**Files Affected**:
- `src/mcp/resultCache.ts` (new)
- `src/mcp/executor.ts`
- `src/settingTab.ts`

#### UserStory-500-20-5: Implement Result Cache

**Priority**: P3
**Story Points**: 5
**Description**: As a user, I need tool results cached so that repeated calls with same parameters use cached data.

##### Task-500-20-5-1: Create ResultCache class

**Story Points**: 2
**Priority**: P3
**File**: `src/mcp/resultCache.ts` (new)

**Implementation**:
```typescript
export class ResultCache {
  private cache: Map<string, CachedResult> = new Map()

  hash(serverId: string, toolName: string, parameters: Record<string, unknown>): string {
    return createHash('sha256')
      .update(JSON.stringify({ serverId, toolName, parameters }))
      .digest('hex')
  }

  get(hash: string): ToolExecutionResult | null { ... }
  set(hash: string, result: ToolExecutionResult, ttl: number): void { ... }
  invalidate(serverId?: string): void { ... }
}
```

**Acceptance Criteria**:
- Given: A tool execution request
- When: Hashing parameters
- Then: Generates stable hash suitable for caching

##### Task-500-20-5-2: Check cache before execution

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/executor.ts`

**Changes Required**:
```typescript
async executeTool(request: ToolExecutionRequest): Promise<ToolExecutionResult> {
  const hash = this.resultCache.hash(request.serverId, request.toolName, request.parameters)
  const cached = this.resultCache.get(hash)
  if (cached) {
    return { ...cached, cached: true }
  }

  // ... existing execution logic
}
```

**Acceptance Criteria**:
- Given: A tool execution request
- When: Checking cache
- Then: Returns cached result if exists and not expired

##### Task-500-20-5-3: Store results with TTL

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/executor.ts`

**Changes Required**:
- Store result after successful execution
- Include timestamp and TTL
- Default TTL: 5 minutes

**Acceptance Criteria**:
- Given: A tool execution completed successfully
- When: Storing in cache
- Then: Includes timestamp and configurable TTL

##### Task-500-20-5-4: Add cache invalidation

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/resultCache.ts`

**Invalidation Triggers**:
- TTL expired (automatic)
- Manual clear command
- Server restart (clear that server's cache)

**Acceptance Criteria**:
- Given: Cached results with expired TTL
- When: Checking cache
- Then: Expired results are removed and not returned

#### UserStory-500-20-10: Cache UI Integration

**Priority**: P3
**Story Points**: 3
**Description**: As a user, I need to see cache status so that I know when results are from cache vs fresh execution.

##### Task-500-20-10-1: Add cache indicator to results

**Story Points**: 1
**Priority**: P3
**File**: `src/mcp/toolCallingCoordinator.ts`

**Display Format**:
```markdown
**Result** (123ms) 📦 Cached (2m ago)
```

**Acceptance Criteria**:
- Given: A tool result from cache
- When: Displaying in document
- Then: Shows "📦 Cached" with age

##### Task-500-20-10-2: Add cache management command

**Story Points**: 1
**Priority**: P3
**File**: `src/main.ts`

**Command**:
```typescript
this.addCommand({
  id: 'clear-mcp-cache',
  name: 'Clear MCP Tool Result Cache',
  callback: () => {
    this.mcpExecutor.resultCache.clear()
    new Notice('MCP cache cleared')
  }
})
```

**Acceptance Criteria**:
- Given: Command palette open
- When: Typing "Clear MCP Cache"
- Then: Clears all cached tool results

##### Task-500-20-10-3: Add cache statistics

**Story Points**: 1
**Priority**: P3
**File**: `src/modals/mcpStatusModal.ts`

**Metrics**:
- Cache hit rate (%)
- Cache size (MB)
- Number of entries
- Oldest entry age

**Acceptance Criteria**:
- Given: Status modal open
- When: Viewing cache section
- Then: Shows hit rate, size, entry count

### Feature-500-30: Execution History Viewer

**Priority**: P3
**Story Points**: 5
**Description**: Modal to view and search past tool executions.

**Files Affected**:
- `src/modals/executionHistoryModal.ts` (new)
- `src/main.ts`

#### UserStory-500-30-5: Build History UI

**Priority**: P3
**Story Points**: 5
**Description**: As a user, I need to view past tool executions so that I can audit and debug tool usage.

##### Task-500-30-5-1: Create ExecutionHistoryModal

**Story Points**: 2
**Priority**: P3
**File**: `src/modals/executionHistoryModal.ts` (new)

**Table Columns**:
- Timestamp
- Server
- Tool Name
- Status (success/error)
- Duration
- Actions (View Details)

**Acceptance Criteria**:
- Given: Execution history data
- When: Opening modal
- Then: Shows table of past executions sorted by timestamp

##### Task-500-30-5-2: Add filters and search

**Story Points**: 2
**Priority**: P3
**File**: `src/modals/executionHistoryModal.ts`

**Filters**:
- Server dropdown
- Tool name search
- Status filter (all/success/error)
- Date range

**Acceptance Criteria**:
- Given: History modal with filters
- When: Filtering by server/tool/status
- Then: Table updates in real-time to show matching entries

##### Task-500-30-5-3: Add detail view

**Story Points**: 1
**Priority**: P3
**File**: `src/modals/executionHistoryModal.ts`

**Detail View Shows**:
- Full parameters (JSON)
- Full result (JSON)
- Metadata (duration, tokens, etc.)
- Error message if failed

**Acceptance Criteria**:
- Given: An execution in the history table
- When: Clicking "View Details"
- Then: Shows expandable panel with parameters, result, and metadata

---

## Epic-600: Testing Infrastructure

**Priority**: P3
**Story Points**: 13
**Status**: Not Started
**Description**: Improve testing infrastructure for better coverage and confidence.

**Dependencies**: Epic-100, Epic-200 (core functionality must exist to test)
**Risk**: Low - improves quality but not user-facing

### Feature-600-10: UI Testing Strategy

**Priority**: P3
**Story Points**: 8
**Description**: Refactor and test UI components without requiring full Obsidian runtime.

**Files Affected**:
- `src/statusBarManager.ts`
- `src/modals/mcpStatusModal.ts`
- `tests/ui/` (new directory)

#### UserStory-600-10-5: Extract Testable UI Logic

**Priority**: P3
**Story Points**: 5
**Description**: As a developer, I need UI logic extracted to pure functions so that I can test without Obsidian API.

##### Task-600-10-5-1: Extract status formatting functions

**Story Points**: 1
**Priority**: P3
**Files**: `src/statusBarManager.ts`, `src/utils/statusFormatting.ts` (new)

**Refactor Example**:
```typescript
// Before:
class StatusBarManager {
  setMCPStatus(status: MCPStatusInfo) {
    this.statusBarItem.setText(`Tars | MCP: ${status.runningServers}/${status.totalServers}`)
  }
}

// After:
// src/utils/statusFormatting.ts
export function formatMCPStatus(status: MCPStatusInfo): string {
  return `Tars | MCP: ${status.runningServers}/${status.totalServers}`
}

// src/statusBarManager.ts
class StatusBarManager {
  setMCPStatus(status: MCPStatusInfo) {
    this.statusBarItem.setText(formatMCPStatus(status))
  }
}
```

**Acceptance Criteria**:
- Given: UI status display logic
- When: Extracting to pure functions in `src/utils/statusFormatting.ts`
- Then: Functions are testable without Obsidian API

##### Task-600-10-5-2: Extract HTML generation functions

**Story Points**: 2
**Priority**: P3
**Files**: `src/modals/mcpStatusModal.ts`, `src/utils/htmlBuilders.ts` (new)

**Refactor Example**:
```typescript
// src/utils/htmlBuilders.ts
export function buildMCPStatusHTML(status: MCPStatusInfo): string {
  return `
    <div class="mcp-status">
      <h2>MCP Status</h2>
      <p>Running: ${status.runningServers}/${status.totalServers}</p>
      <p>Tools: ${status.availableTools}</p>
    </div>
  `
}

// src/modals/mcpStatusModal.ts
class MCPStatusModal extends Modal {
  onOpen() {
    const html = buildMCPStatusHTML(this.mcpStatus)
    this.contentEl.innerHTML = html
  }
}
```

**Acceptance Criteria**:
- Given: Modal content generation logic
- When: Extracting to builder functions
- Then: Returns HTML string that is testable without Obsidian

##### Task-600-10-5-3: Add unit tests for UI logic

**Story Points**: 2
**Priority**: P3
**File**: `tests/ui/statusFormatting.test.ts` (new)

**Test Cases**:
1. `formatMCPStatus` with various inputs
2. `buildMCPStatusHTML` with different server counts
3. Status formatting edge cases (0 servers, all failed, etc.)

**Acceptance Criteria**:
- Given: Extracted UI formatting functions
- When: Running unit tests
- Then: All formatting/generation logic is covered

#### UserStory-600-10-10: Playwright E2E Setup

**Priority**: P3
**Story Points**: 3
**Description**: As a developer, I need E2E tests for critical UI flows so that I can catch integration bugs.

##### Task-600-10-10-1: Install and configure Playwright

**Story Points**: 1
**Priority**: P3
**Files**: `package.json`, `playwright.config.ts` (new)

**Installation**:
```bash
npm install -D @playwright/test
npx playwright install
```

**Config**:
```typescript
// playwright.config.ts
export default defineConfig({
  testDir: './tests/e2e-ui',
  timeout: 30000,
  use: {
    baseURL: 'obsidian://vault/test-vault',
  },
})
```

**Acceptance Criteria**:
- Given: Project dependencies
- When: Installing `@playwright/test`
- Then: Configured for Obsidian app testing with custom protocol

##### Task-600-10-10-2: Create test vault setup script

**Story Points**: 1
**Priority**: P3
**File**: `scripts/setup-test-vault.sh` (new)

**Script Actions**:
1. Create test vault directory
2. Copy plugin build to `.obsidian/plugins/tars`
3. Enable plugin in vault config
4. Populate with sample data

**Acceptance Criteria**:
- Given: Build output in `dist/`
- When: Running setup script
- Then: Test vault created with plugin installed and enabled

##### Task-600-10-10-3: Write sample E2E test

**Story Points**: 1
**Priority**: P3
**File**: `tests/e2e-ui/mcp-settings.spec.ts` (new)

**Sample Test**:
```typescript
import { test, expect } from '@playwright/test'

test('MCP settings panel visible', async ({ page }) => {
  await page.goto('obsidian://vault/test-vault')
  await page.click('[aria-label="Settings"]')
  await page.click('text=Tars')
  await page.click('summary:has-text("MCP Servers")')

  await expect(page.locator('text=Global timeout')).toBeVisible()
  await expect(page.locator('button:has-text("Add Custom MCP Server")')).toBeVisible()
})
```

**Acceptance Criteria**:
- Given: A Playwright test
- When: Opening settings and navigating to MCP section
- Then: Verifies MCP UI elements are visible

### Feature-600-20: Coverage Improvements

**Priority**: P3
**Story Points**: 5
**Description**: Add tests for scenarios not currently covered.

**Files Affected**:
- Various test files

#### UserStory-600-20-5: Missing Test Coverage

**Priority**: P3
**Story Points**: 5
**Description**: As a developer, I need tests for uncovered scenarios so that I have confidence in code changes.

##### Task-600-20-5-1: Add timeout handling tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/executor.test.ts`

**Test Cases**:
1. Tool execution exceeds timeout
2. Timeout error is thrown
3. Execution is cleaned up properly
4. activeExecutions set is updated

**Acceptance Criteria**:
- Given: Tool execution with timeout
- When: Tool exceeds configured timeout
- Then: Error is thrown and execution is cleaned up

##### Task-600-20-5-2: Add Claude adapter tests

**Story Points**: 2
**Priority**: P3
**File**: `tests/mcp/claudeProviderAdapter.test.ts` (new)

**Test Coverage**:
1. Initialize adapter
2. Build tools in Claude format
3. Parse tool_use from streaming events
4. Format tool results
5. Multi-turn conversation

**Acceptance Criteria**:
- Given: `ClaudeProviderAdapter` implementation
- When: Running test suite
- Then: All adapter methods have test coverage

##### Task-600-20-5-3: Add health check tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/managerMCPUse.test.ts`

**Test Cases**:
1. Health check updates status correctly
2. Disconnected servers marked unhealthy
3. Health status persists across checks

**Acceptance Criteria**:
- Given: Health check timer running
- When: Checking server health
- Then: Status is updated correctly in health map

##### Task-600-20-5-4: Add error scenario tests

**Story Points**: 1
**Priority**: P3
**File**: `tests/mcp/errorHandling.test.ts` (new)

**Error Scenarios**:
1. Server fails to start
2. Tool execution throws error
3. Network timeout
4. Invalid tool parameters
5. Server disconnects during execution

**Acceptance Criteria**:
- Given: Various error conditions
- When: Running tests
- Then: All error paths are tested and handled correctly

---

## Summary & Timeline

### Overview by Epic

| Epic | Priority | Story Points | Estimated Duration | Dependencies |
|------|----------|--------------|-------------------|--------------|
| Epic-100: Critical Bug Fixes | P0 | 8 | 1-2 days | None |
| Epic-200: Core Missing Features | P1 | 21 | 1 week | Epic-100 |
| Epic-300: Performance & Resources | P2 | 13 | 3-4 days | Epic-100, Epic-200 |
| Epic-400: User Experience | P2 | 21 | 1 week | Epic-100, Epic-200 |
| Epic-500: Advanced Features | P3 | 21 | 1 week | Epic-100-400 |
| Epic-600: Testing Infrastructure | P3 | 13 | 3-4 days | Epic-100, Epic-200 |

**Total Story Points**: 101
**Estimated Timeline**: 4-6 weeks for full implementation

### Priority Breakdown

- **P0 (Blockers)**: 8 points (~1-2 days) - Must fix before any release
- **P1 (Critical)**: 21 points (~1 week) - Required for complete feature
- **P2 (Important)**: 47 points (~2-3 weeks) - Greatly improves UX
- **P3 (Nice to have)**: 25 points (~1-2 weeks) - Advanced features, can defer

### Recommended Implementation Phases

#### Phase 1: Stabilization (P0) - Week 1
**Goal**: Fix production blockers, make MCP integration functional

- Epic-100: Critical Bug Fixes (8 pts)
  - Fix ID/name mismatch
  - Enable settings (timeout, limits)
  - Activate health monitoring

**Outcome**: MCP integration works reliably, settings are respected

#### Phase 2: Core Completeness (P1) - Weeks 2-3
**Goal**: Complete missing core features

- Epic-200: Core Missing Features (21 pts)
  - Auto-disable failed servers
  - Claude provider integration
  - Tool result persistence in documents

**Outcome**: Full provider coverage, tool results visible, better reliability

#### Phase 3: Optimization (P2) - Weeks 3-4
**Goal**: Improve performance and UX

- Epic-300: Performance & Resources (13 pts)
  - Tool discovery caching
  - Memory leak prevention
  - Error recovery with retry

**Outcome**: Better performance, fewer resource issues

#### Phase 4: User Experience (P2) - Weeks 4-5
**Goal**: Make MCP tools discoverable and easy to use

- Epic-400: User Experience Enhancements (21 pts)
  - Tool browser modal
  - Auto-completion
  - Enhanced status display

**Outcome**: Users can easily discover and use tools

#### Phase 5: Advanced Features (P3) - Week 6
**Goal**: Power-user features (optional)

- Epic-500: Advanced Features (21 pts)
  - Parallel tool execution
  - Result caching
  - Execution history viewer

**Outcome**: Advanced workflows enabled

#### Phase 6: Quality Assurance (P3) - Week 6
**Goal**: Improve test coverage

- Epic-600: Testing Infrastructure (13 pts)
  - UI testing strategy
  - Coverage improvements

**Outcome**: Higher confidence in changes

### Notes for LLM Implementers

1. **Start with Phase 1** (Epic-100) - don't skip these blockers
2. **Test thoroughly** - each task has acceptance criteria that define tests
3. **Update this document** - mark completed items, add discovered work
4. **Ask for clarification** - if acceptance criteria are unclear
5. **Follow existing patterns** - maintain consistency with current code style
6. **Document changes** - update relevant docs when adding features

### Cross-Reference Links

- **Original Review**: [2025-10-03-mcp-integration-review.md](2025-10-03-mcp-integration-review.md)
- **Codebase Root**: `src/`
- **Test Root**: `tests/`
- **Settings**: `src/settingTab.ts`
- **Main Plugin**: `src/main.ts`
- **MCP Core**: `src/mcp/`

---

**Document Version**: 1.0
**Last Updated**: 2025-10-03
**Estimated Total Effort**: 101 story points (~4-6 weeks)
**Status**: Ready for Implementation
